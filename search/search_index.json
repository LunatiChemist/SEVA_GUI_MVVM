{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SEVA Developer Documentation","text":"<p>Welcome to the SEVA documentation.</p> <p>This documentation is intended for developers working on the SEVA GUI (MVVM architecture) and the associated REST API.</p> <p>Docs track the <code>main</code> branch unless otherwise noted.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>SEVA was created because the previous GUI was difficult to extend and even harder to migrate when device communication changed. Once control moved to network-based pyBEEP integration, the UI needed to work reliably with a REST API boundary, but the old structure mixed concerns too much to support that shift cleanly.</p> <p>The core goal of this project is pragmatic maintainability: new features should be added without rewriting unrelated UI code, and infrastructure changes should not force architecture-wide refactors. MVVM + Hexagonal boundaries make that possible by keeping Views and ViewModels focused on UI state, moving workflow orchestration into UseCases, and isolating all external I/O in adapters.</p> <p>This also improves diversification and long-term evolution. Through ports and adapters, transport/back-end integrations can be swapped more safely (for example REST-based integration vs. legacy AMETEK-style paths) while preserving GUI workflows. In run execution, server-reported state remains the single source of truth for status/progress, which avoids fragile client-side assumptions and keeps behavior testable at the use-case boundary.</p>"},{"location":"#start-here","title":"Start here","text":"<p>If you are new to the project, follow this order:</p> <ol> <li>Read What is this repo? (below) to understand the scope.</li> <li>Set up your environment in Development Setup.</li> <li>Configure/deploy the API with REST API Setup Tutorial.</li> <li>Review the Architecture Overview to learn the MVVM + Hexagonal boundaries.</li> <li>Work through the MVVM + Hexagonal Tutorial Notebooks for a guided architecture walkthrough.</li> <li>Explore the SEVA GUI workflows and REST API workflows.</li> <li>Use Troubleshooting and the Glossary when you get stuck.</li> <li>Review the ChatGPT Codex Guide for AI-assisted changes.</li> </ol>"},{"location":"#quick-path-chooser","title":"Quick path chooser","text":"<p>Use this if you want the shortest path to a specific task:</p> <ul> <li>I want to run GUI/API locally -&gt; Development Setup, then REST API Setup Tutorial.</li> <li>I want to understand architecture boundaries -&gt; Architecture Overview.</li> <li>I need call-chain debugging for start/poll/cancel -&gt; SEVA GUI Workflows and REST API Workflows.</li> <li>I need endpoint/module reference details -&gt; REST API Classes &amp; Modules and SEVA GUI Classes &amp; Modules.</li> <li>I need end-user GUI operation help -&gt; GUI Overview &amp; How to Use.</li> </ul>"},{"location":"#what-is-this-repo","title":"What is this repo?","text":"<p>This repository contains the SEVA GUI (MVVM + Hexagonal architecture) and the associated REST API service. The GUI lives in <code>seva/</code>, and the REST API lives in <code>rest_api/</code>.</p>"},{"location":"#how-to-run-gui-locally-windowslinux","title":"How to run GUI locally (Windows/Linux)","text":"<p>Follow the steps in Development Setup to configure Python and start the GUI.</p>"},{"location":"#how-to-run-rest-api-locally-linuxraspberry-pi","title":"How to run REST API locally (Linux/Raspberry Pi)","text":"<p>See REST API Setup Tutorial for the complete Linux/Raspberry Pi setup, including install, verification, and restart steps.</p>"},{"location":"#where-to-change-what-view-vs-viewmodel-vs-usecase","title":"Where to change what? (View vs ViewModel vs UseCase)","text":"<p>Use this quick guide when deciding where a change should live:</p> <ul> <li>Views (<code>seva/app/views/*</code>): UI rendering only.</li> <li>ViewModels (<code>seva/viewmodels/*</code>): UI state + commands.</li> <li>UseCases (<code>seva/usecases/*</code>): Orchestration and workflows.</li> <li>Adapters (<code>seva/adapters/*</code>): External I/O (HTTP, filesystem, discovery).</li> </ul>"},{"location":"#scope","title":"Scope","text":"<p>This documentation set contains two tracks:</p> <ul> <li>Developer docs (architecture, setup, workflows, module responsibilities)</li> <li>User guide docs (GUI operation walkthroughs)</li> </ul> <p>The primary focus remains developer-oriented material for contributors working inside <code>seva/</code> and <code>rest_api/</code>.</p>"},{"location":"#documentation-map","title":"Documentation map","text":""},{"location":"#developer-track","title":"Developer track","text":"<p>Follow this order for a linear tour through the docs:</p> <ol> <li>Development Setup (local environment + run GUI/API)</li> <li>REST API Setup Tutorial (API install, env, smoke tests, restart)</li> <li>Architecture Overview (MVVM + Hexagonal boundaries)</li> <li>MVVM + Hexagonal Tutorial Notebooks</li> <li>SEVA GUI workflows</li> <li>REST API workflows</li> <li>Troubleshooting</li> <li>Glossary</li> <li>ChatGPT Codex Guide</li> </ol>"},{"location":"#user-guide-track","title":"User guide track","text":"<ul> <li>GUI Overview &amp; How to Use</li> </ul>"},{"location":"architecture_overview/","title":"Architecture Overview (GUI + REST API)","text":"<p>The SEVA GUI (<code>seva/</code>) follows MVVM + Hexagonal architecture and talks to the FastAPI service (<code>rest_api/</code>) through adapter ports.</p>"},{"location":"architecture_overview/#layer-responsibilities","title":"Layer Responsibilities","text":"<ul> <li>Views render UI only.</li> <li>ViewModels expose UI state and commands only.</li> <li>UseCases orchestrate workflows.</li> <li>Adapters handle external I/O (HTTP, filesystem, discovery).</li> <li>Domain modules own shared types, validation, naming, and normalization.</li> </ul> <pre><code>flowchart LR\n    subgraph GUI\n        View[View&lt;br/&gt;UI only] --&gt; ViewModel[ViewModel&lt;br/&gt;State + commands]\n        ViewModel --&gt; UseCase[UseCase&lt;br/&gt;Workflow orchestration]\n    end\n    UseCase --&gt; Adapter[Adapter&lt;br/&gt;I/O boundary]\n    Adapter --&gt; API[REST API / External Systems]\n</code></pre>"},{"location":"architecture_overview/#guided-architecture-tutorial-notebooks","title":"Guided architecture tutorial (Notebooks)","text":"<p>For a step-by-step onboarding path, use the tutorial notebooks in <code>docs/</code>:</p> <ol> <li><code>mvvm_hexagonal_intro.ipynb</code></li> <li><code>mvvm_hexagonal_part2_view_viewmodel.ipynb</code></li> </ol> <p>These notebooks are designed to be read after this overview and before diving into concrete workflow docs.</p>"},{"location":"architecture_overview/#cross-system-call-chain","title":"Cross-System Call-Chain","text":"<p>A typical user action flows as:</p> <ol> <li>Tkinter view event in <code>seva/app/views/*</code>.</li> <li>ViewModel command in <code>seva/viewmodels/*</code>.</li> <li>UseCase orchestration in <code>seva/usecases/*</code>.</li> <li>Adapter port call in <code>seva/adapters/*</code>.</li> <li>REST endpoint in <code>rest_api/app.py</code> and helper modules.</li> </ol> <pre><code>sequenceDiagram\n    participant User\n    participant View as View (Tkinter)\n    participant VM as ViewModel\n    participant UC as UseCase\n    participant Adapter as Adapter\n    participant API as REST API\n\n    User-&gt;&gt;View: clicks / edits\n    View-&gt;&gt;VM: command callback\n    VM-&gt;&gt;UC: invoke use case\n    UC-&gt;&gt;Adapter: port call\n    Adapter-&gt;&gt;API: HTTP request\n    API--&gt;&gt;Adapter: response\n    Adapter--&gt;&gt;UC: domain data\n    UC--&gt;&gt;VM: updated state\n    VM--&gt;&gt;View: render updates\n</code></pre>"},{"location":"classes_rest_api/","title":"REST API Classes and Modules","text":"<p>This document describes every Python module in <code>rest_api/</code> and how each one participates in the GUI -&gt; API -&gt; storage/device call-chain.</p>"},{"location":"classes_rest_api/#module-inventory-and-integration-map","title":"Module inventory and integration map","text":"<p>The REST package currently contains the following Python modules:</p> <ul> <li><code>rest_api/__init__.py</code>: package-level orientation docstring.</li> <li><code>rest_api/app.py</code>: FastAPI entrypoint, route definitions, in-memory job/device registries, and worker orchestration.</li> <li><code>rest_api/validation.py</code>: mode payload validators for <code>/modes/{mode}/validate</code>.</li> <li><code>rest_api/progress_utils.py</code>: progress and ETA computations used in status snapshots.</li> <li><code>rest_api/storage.py</code>: run-directory naming, sanitization, and persisted run-id path registry.</li> <li><code>rest_api/nas_smb.py</code>: SMB/CIFS upload adapter used by <code>/nas/*</code> and <code>/runs/{run_id}/upload</code>.</li> <li><code>rest_api/nas.py</code>: SSH/rsync NAS adapter kept for SSH-based deployments.</li> <li><code>rest_api/auto_flash_linux.py</code>: Linux firmware flashing subprocess helper for <code>/firmware/flash</code>.</li> <li><code>rest_api/update_package.py</code>: package-update contract validation, async worker, lock, and audit orchestration.</li> </ul>"},{"location":"classes_rest_api/#rest_apiapppy","title":"<code>rest_api/app.py</code>","text":"<p><code>app.py</code> is the only HTTP surface consumed by the GUI. The route families map to adapters and usecases as follows:</p> <ul> <li>Device discovery and mode metadata:</li> <li>GUI callers: <code>seva/adapters/device_rest.py</code></li> <li>Endpoints: <code>/health</code>, <code>/devices</code>, <code>/devices/status</code>, <code>/modes</code>, <code>/modes/{mode}/params</code></li> <li>Validation/start/poll/cancel/download:</li> <li>GUI callers: <code>seva/adapters/job_rest.py</code></li> <li>Endpoints: <code>/modes/{mode}/validate</code>, <code>/jobs</code>, <code>/jobs/status</code>, <code>/jobs/{run_id}</code>, <code>/jobs/{run_id}/cancel</code>, <code>/runs/{run_id}/files</code>, <code>/runs/{run_id}/file</code>, <code>/runs/{run_id}/zip</code></li> <li>Firmware flashing:</li> <li>GUI callers: <code>seva/adapters/firmware_rest.py</code></li> <li>Endpoint: <code>/firmware/flash</code></li> <li>Remote package updates:</li> <li>GUI callers: <code>seva/adapters/update_rest.py</code></li> <li>Endpoints: <code>/updates/package</code>, <code>/updates/{update_id}</code>, <code>/updates</code></li> <li>NAS management:</li> <li>GUI callers: NAS settings flows through REST clients</li> <li>Endpoints: <code>/nas/setup</code>, <code>/nas/health</code>, <code>/runs/{run_id}/upload</code></li> <li>Telemetry demo stream:</li> <li>Endpoint: <code>/api/telemetry/temperature/latest</code>, <code>/api/telemetry/temperature/stream</code></li> </ul>"},{"location":"classes_rest_api/#rest-endpoint-reference-rest_apiapppy","title":"REST endpoint reference (<code>rest_api/app.py</code>)","text":"<p>The table below provides a practical, per-endpoint overview of method, purpose, and primary integration points.</p> Method Path Handler Purpose Typical caller(s) GET <code>/version</code> <code>version_info</code> Returns API/runtime/build metadata for diagnostics and support. Manual ops checks, service introspection GET <code>/health</code> <code>health</code> Basic service liveness + discovered device count. <code>seva.adapters.discovery_http</code>, startup checks GET <code>/devices</code> <code>list_devices</code> Enumerates discovered potentiostat slots and port metadata. <code>seva.adapters.device_rest</code> GET <code>/devices/status</code> <code>list_device_status</code> Returns slot state derived from active jobs (<code>idle/queued/running/...</code>). GUI status polling GET <code>/modes</code> <code>list_modes</code> Lists available measurement modes exposed by controller integration. GUI mode selectors GET <code>/modes/{mode}/params</code> <code>mode_params</code> Returns parameter schema/details for one measurement mode. Dynamic parameter forms POST <code>/modes/{mode}/validate</code> <code>validate_mode_params</code> Validates mode payload via <code>validation.validate_mode_payload</code>. Pre-flight form validation POST <code>/jobs/status</code> <code>jobs_bulk_status</code> Bulk status snapshots for many run IDs in one request. <code>seva.adapters.job_rest</code> polling loops GET <code>/jobs</code> <code>list_jobs</code> Lists runs (supports filtering such as incomplete/completed and group). Run overview panels POST <code>/jobs</code> <code>start_job</code> Creates a run, allocates slots, spawns worker threads, and initializes storage metadata. Start-experiment use cases POST <code>/jobs/{run_id}/cancel</code> <code>cancel_job</code> Signals cancellation and updates queued/running slot states. Cancel actions in GUI GET <code>/jobs/{run_id}</code> <code>job_status</code> Single-run detailed status snapshot with server-computed progress fields. Per-run detail/polling GET <code>/runs/{run_id}/files</code> <code>list_run_files</code> Enumerates files in a run directory for browsing/download selection. Result browser UI GET <code>/runs/{run_id}/file</code> <code>get_run_file</code> Streams a specific artifact file from run output. Single-file downloads GET <code>/runs/{run_id}/zip</code> <code>get_run_zip</code> Streams zipped run artifacts for complete result export. \u201cDownload all\u201d actions POST <code>/nas/setup</code> <code>nas_setup</code> Persists SMB NAS configuration and performs initial connectivity probe. NAS settings workflow GET <code>/nas/health</code> <code>nas_health</code> Reports current NAS connectivity state from manager probes. NAS status indicator POST <code>/runs/{run_id}/upload</code> <code>nas_upload_run</code> Queues manual upload of one run to configured NAS target. Post-run offload action POST <code>/admin/rescan</code> <code>rescan</code> Triggers fresh hardware discovery scan. Admin/maintenance tools POST <code>/updates/package</code> <code>start_package_update</code> Stores update ZIP, acquires update lock, and enqueues async apply workflow. <code>seva.adapters.update_rest</code> GET <code>/updates/{update_id}</code> <code>get_package_update</code> Returns server-authoritative package-update status, step, heartbeat, and error/audit details. <code>seva.adapters.update_rest</code> GET <code>/updates</code> <code>list_package_updates</code> Lists recent package-update jobs for diagnostics. Manual ops checks, update dashboards POST <code>/firmware/flash</code> <code>flash_firmware</code> Stores uploaded firmware binary and invokes Linux flashing subprocess flow. <code>seva.adapters.firmware_rest</code> GET <code>/api/telemetry/temperature/latest</code> <code>get_latest</code> Returns latest cached telemetry sample per device (demo endpoint). Telemetry demos GET <code>/api/telemetry/temperature/stream</code> <code>temperature_stream</code> SSE stream emitting periodic telemetry + keepalive pings (demo endpoint). Streaming demo clients"},{"location":"classes_rest_api/#requestresponse-behavior-notes","title":"Request/response behavior notes","text":"<ul> <li>Authentication boundary: most operational endpoints check <code>x-api-key</code> via <code>require_key(...)</code>; keep adapter defaults aligned with deployment env vars (<code>BOX_API_KEY</code>).</li> <li>Status authority: <code>job_snapshot(...)</code> enriches <code>JobStatus</code> with <code>progress_pct</code> and <code>remaining_s</code> using <code>progress_utils.compute_progress(...)</code>; clients should treat these fields as authoritative.</li> <li>Storage resolution: run file/download/upload routes resolve directories through <code>storage.resolve_run_directory(...)</code> so callers should only persist <code>run_id</code>, never file-system paths.</li> <li>Validation contract: <code>/modes/{mode}/validate</code> always returns structured <code>ValidationResult</code> (<code>ok</code>, <code>errors</code>, <code>warnings</code>) to keep GUI feedback deterministic.</li> </ul> <p>Important type contracts in <code>app.py</code>:</p> <ul> <li><code>DeviceInfo</code>: discovered slot metadata (<code>slot</code>, <code>port</code>, optional serial number).</li> <li><code>JobRequest</code>: request body for start-job orchestration (devices, modes, params, naming fields).</li> <li><code>SlotStatus</code>: slot-local state machine (<code>idle|queued|running|done|failed|cancelled</code>) plus timestamps/files.</li> <li><code>JobStatus</code>: run-level aggregate status with <code>progress_pct</code> and <code>remaining_s</code> from server computations.</li> <li><code>JobOverview</code>: compact listing payload for <code>/jobs</code> list views.</li> <li><code>JobStatusBulkRequest</code>: body schema for multi-run polling.</li> <li><code>SMBSetupRequest</code>: NAS configuration payload.</li> <li><code>TemperatureSample</code>, <code>LatestResponse</code>, <code>MockPotentiostatSource</code>: telemetry demo payload/model set.</li> </ul> <p>Key orchestration functions:</p> <ul> <li><code>_run_one_slot(...)</code> and <code>_run_slot_sequence(...)</code>: per-slot worker execution for single-mode or multi-mode runs.</li> <li><code>_update_job_status_locked(...)</code>: recomputes aggregate job status from per-slot states.</li> <li><code>job_snapshot(...)</code>: enriches snapshots with progress/remaining-time using <code>progress_utils</code>.</li> <li><code>_build_run_storage_info(...)</code>: creates sanitized storage naming metadata from request fields.</li> </ul>"},{"location":"classes_rest_api/#rest_apivalidationpy","title":"<code>rest_api/validation.py</code>","text":"<p>This module implements the validator dispatch used by <code>/modes/{mode}/validate</code>.</p> <p>Core contracts:</p> <ul> <li><code>ValidationIssue</code>: one machine-readable issue with <code>field</code>, <code>code</code>, and <code>message</code>.</li> <li><code>ValidationResult</code>: response envelope with <code>ok</code>, <code>errors</code>, and <code>warnings</code>.</li> <li><code>UnsupportedModeError</code>: thrown when no validator is registered for the requested mode.</li> </ul> <p>Validation behavior summary:</p> <ul> <li><code>CV</code> has explicit numeric and range checks plus quality warnings.</li> <li><code>DC</code>, <code>AC</code>, <code>LSV</code>, <code>EIS</code>, <code>CDL</code>, <code>CA</code> currently verify required fields and return an explicit <code>not_implemented</code> warning.</li> <li><code>validate_mode_payload(...)</code> normalizes mode tokens and dispatches to <code>_MODE_VALIDATORS</code>.</li> </ul>"},{"location":"classes_rest_api/#rest_apiprogress_utilspy","title":"<code>rest_api/progress_utils.py</code>","text":"<p>Pure computation module called from <code>app.py</code> status routes.</p> <ul> <li><code>estimate_planned_duration(mode, params)</code>: computes expected duration for CV/CA/CP/OCP/LSV/PSTEP/GS/GCV/STEPSEQ/DC/EIS modes.</li> <li><code>compute_progress(...)</code>: derives run-level <code>%</code> progress and remaining seconds from slot states and timestamps.</li> <li><code>utcnow_iso()</code> and <code>parse_iso(...)</code>: UTC timestamp helpers used across job snapshots.</li> </ul> <p>The output from this module is the server-authoritative progress signal consumed by GUI viewmodels.</p>"},{"location":"classes_rest_api/#rest_apistoragepy","title":"<code>rest_api/storage.py</code>","text":"<p>Single source of truth for run-path handling.</p> <ul> <li><code>RunStorageInfo</code>: normalized folder and filename token bundle used during start-job.</li> <li>Sanitizers:</li> <li><code>sanitize_path_segment(...)</code></li> <li><code>sanitize_optional_segment(...)</code></li> <li><code>sanitize_client_datetime(...)</code></li> <li>Registry persistence:</li> <li><code>record_run_directory(...)</code></li> <li><code>resolve_run_directory(...)</code></li> <li><code>forget_run_directory(...)</code></li> <li><code>configure_runs_root(...)</code></li> </ul> <p>Persistence format:</p> <ul> <li>File: <code>&lt;RUNS_ROOT&gt;/_run_paths.json</code></li> <li>Content: JSON object mapping <code>run_id</code> -&gt; relative run path</li> </ul>"},{"location":"classes_rest_api/#rest_apinas_smbpy","title":"<code>rest_api/nas_smb.py</code>","text":"<p>Active NAS adapter for SMB/CIFS shares.</p> <ul> <li><code>SMBConfig</code>: host/share credentials, mount options, retention configuration.</li> <li><code>NASManager.setup(...)</code>: persists config + credentials and validates mountability.</li> <li><code>NASManager.health(...)</code>: probes current connectivity.</li> <li><code>NASManager.enqueue_upload(...)</code>: queues async upload workers.</li> <li><code>NASManager._upload_worker(...)</code>: mounts share, copies run files via <code>rsync</code>, verifies file count, writes <code>UPLOAD_DONE</code> marker.</li> <li>Background tasks:</li> <li>initial health probe</li> <li>retention cleanup (deletes local runs after successful upload and retention window)</li> </ul>"},{"location":"classes_rest_api/#rest_apinaspy","title":"<code>rest_api/nas.py</code>","text":"<p>SSH/rsync NAS adapter variant.</p> <ul> <li><code>NASConfig</code>: SSH target and key configuration.</li> <li><code>NASManager.setup(...)</code>: key provisioning + remote folder bootstrap.</li> <li><code>NASManager.health(...)</code>: SSH key login probe.</li> <li><code>NASManager.enqueue_upload(...)</code> / <code>_upload_worker(...)</code>: async rsync upload + minimal verification.</li> <li>Retention flow mirrors SMB manager behavior.</li> </ul> <p>This module remains useful for environments where SMB mounts are unavailable.</p>"},{"location":"classes_rest_api/#rest_apiauto_flash_linuxpy","title":"<code>rest_api/auto_flash_linux.py</code>","text":"<p>Subprocess utility invoked by <code>/firmware/flash</code>.</p> <p>Execution chain:</p> <ol> <li>receive <code>.bin</code> path as CLI arg</li> <li>discover CDC serial port by VID/PID</li> <li>send boot command (<code>BOOT_DFU_MODE</code>)</li> <li>wait for DFU enumeration (<code>dfu-util -l</code>)</li> <li>flash binary with <code>dfu-util</code></li> <li>wait for CDC serial to reappear</li> </ol> <p>Failure behavior is exit-code driven so <code>app.py</code> can convert it into a typed HTTP error payload.</p>"},{"location":"classes_rest_api/#rest_apiupdate_packagepy","title":"<code>rest_api/update_package.py</code>","text":"<p>This module owns package-update orchestration used by <code>/updates/*</code>:</p> <ul> <li>manifest + checksum validation (<code>manifest.json</code>, <code>checksums.sha256</code>)</li> <li>ZIP path safety checks and SHA-256 verification</li> <li>service-wide single-job lock (<code>updates.locked</code>)</li> <li>asynchronous worker apply order (<code>pybeep</code> -&gt; <code>rest_api</code> -&gt; <code>firmware</code>)</li> <li>shared firmware flash callback reuse from <code>/firmware/flash</code> logic</li> <li>restart command execution and per-job restart result capture</li> <li>JSONL audit event writing per update id</li> </ul>"},{"location":"classes_seva/","title":"SEVA Classes and Modules","text":"<p>This document maps the GUI code in <code>seva/</code> to MVVM + Hexagonal layers.</p>"},{"location":"classes_seva/#scope","title":"Scope","text":"<ul> <li>Domain models and registries (<code>seva/domain</code>)</li> <li>Ports and adapter implementations (<code>seva/domain/ports.py</code>, <code>seva/adapters</code>)</li> <li>Use-case orchestration (<code>seva/usecases</code>)</li> <li>ViewModels and UI composition (<code>seva/viewmodels</code>, <code>seva/app</code>)</li> </ul>"},{"location":"classes_seva/#layer-boundaries","title":"Layer Boundaries","text":"<ul> <li>Views: render and event wiring only.</li> <li>ViewModels: UI state + commands only.</li> <li>UseCases: orchestration and workflow sequencing.</li> <li>Adapters: external I/O implementations.</li> <li>Domain: typed objects, validation, naming, and normalization helpers.</li> </ul>"},{"location":"classes_seva/#domain-sevadomain","title":"Domain (<code>seva/domain</code>)","text":""},{"location":"classes_seva/#core-entities","title":"Core entities","text":"<p><code>seva/domain/entities.py</code> defines immutable value objects and aggregates used above adapter boundaries:</p> <ul> <li>identity/value objects: <code>GroupId</code>, <code>RunId</code>, <code>WellId</code>, <code>BoxId</code>, <code>ModeName</code></li> <li>time and scalar wrappers: <code>ClientDateTime</code>, <code>ServerDateTime</code>, <code>ProgressPct</code>, <code>Seconds</code></li> <li>planning aggregates: <code>ModeParams</code>, <code>PlanMeta</code>, <code>WellPlan</code>, <code>ExperimentPlan</code></li> <li>polling aggregates: <code>RunStatus</code>, <code>BoxSnapshot</code>, <code>GroupSnapshot</code></li> </ul> <p>Domain invariants enforced in constructors:</p> <ul> <li>all identity wrappers (<code>GroupId</code>, <code>RunId</code>, <code>WellId</code>, <code>BoxId</code>, <code>ModeName</code>) reject blank strings</li> <li>timestamp wrappers (<code>ClientDateTime</code>, <code>ServerDateTime</code>) require timezone-aware <code>datetime</code></li> <li>scalar wrappers (<code>ProgressPct</code>, <code>Seconds</code>) normalize numeric input and reject out-of-range values</li> <li><code>ExperimentPlan</code> requires at least one <code>WellPlan</code>; <code>GroupSnapshot</code> validates typed map keys/values</li> </ul> <p>Typical call chain:</p> <ul> <li><code>ExperimentViewModel</code> field snapshots -&gt; <code>build_experiment_plan.py</code> -&gt; <code>PlanMeta</code>/<code>WellPlan</code>/<code>ExperimentPlan</code></li> <li><code>JobPort.poll_group</code> adapter payload -&gt; <code>poll_group_status.py</code> -&gt; <code>snapshot_normalizer.py</code> -&gt; <code>GroupSnapshot</code></li> </ul>"},{"location":"classes_seva/#mode-registry-and-parameters","title":"Mode registry and parameters","text":"<ul> <li><code>seva/domain/modes.py</code>: <code>ModeRegistry</code> and <code>ModeRule</code> own normalization, labels, and mode-specific form filtering.</li> <li><code>seva/domain/params/*.py</code>: typed mode parameter builders (<code>CVParams</code>, <code>ACParams</code>, <code>DCParams</code>, <code>EISParams</code>, <code>CDLParams</code>) and payload serialization.</li> </ul> <p>Mode registry responsibilities (single source of truth):</p> <ul> <li>normalize mode keys for lookups (<code>_normalize_key</code>) and backend token mapping (<code>backend_token</code>)</li> <li>provide UI labels (<code>label_for</code>) and clipboard targets (<code>clipboard_attr_for</code>)</li> <li>determine mode-owned fields (<code>is_mode_field</code>, <code>filter_fields</code>) so ViewModels avoid hardcoded field lists</li> <li>map mode names to typed parameter builders (<code>builder_for</code>) used by plan construction use cases</li> </ul> <p>Parameter schema mapping examples:</p> <ul> <li><code>CVParams.from_form</code> reads <code>cv.*</code> keys and serializes to compact CV payload fields (<code>start</code>, <code>vertex1</code>, ...)</li> <li><code>ACParams.from_form</code> reads <code>ea.*</code> + <code>control_mode</code>, derives <code>voltage_v</code>/<code>current_ma</code>, and omits empty values</li> <li>each params class extracts run flags (<code>run_*</code>, <code>eval_cdl</code>) into <code>ModeParams.flags</code> for mode toggles</li> </ul>"},{"location":"classes_seva/#mapping-and-normalization-helpers","title":"Mapping and normalization helpers","text":"<ul> <li><code>seva/domain/mapping.py</code>: box/slot to well-id mapping and slot parsing.</li> <li><code>seva/domain/naming.py</code>: deterministic group-id generation.</li> <li><code>seva/domain/time_utils.py</code>: timezone-aware parsing of client timestamps.</li> <li><code>seva/domain/snapshot_normalizer.py</code>: adapter payload to <code>GroupSnapshot</code> normalization.</li> <li><code>seva/domain/layout_utils.py</code>: selection normalization for layout operations.</li> <li><code>seva/domain/storage_meta.py</code>: <code>StorageMeta</code> for output path metadata.</li> </ul>"},{"location":"classes_seva/#domain-registries-and-contracts","title":"Domain registries and contracts","text":"<ul> <li><code>seva/domain/runs_registry.py</code>: persistent registry for run groups and runtime attachment points.</li> <li><code>seva/domain/discovery.py</code>: discovery contracts (<code>DiscoveredBox</code>, <code>DeviceDiscoveryPort</code>).</li> <li><code>seva/domain/ports.py</code>: hexagonal ports (<code>JobPort</code>, <code>DevicePort</code>, <code>StoragePort</code>, <code>RelayPort</code>, <code>FirmwarePort</code>).</li> <li><code>seva/domain/device_activity.py</code>: typed activity snapshot objects for channel activity UI.</li> </ul>"},{"location":"classes_seva/#reserved-compatibility-modules","title":"Reserved compatibility modules","text":"<ul> <li><code>seva/domain/models.py</code>: compatibility placeholder pointing to <code>entities</code>.</li> <li><code>seva/domain/errors.py</code> and <code>seva/domain/validation.py</code>: reserved extension points for shared domain-wide rules.</li> </ul>"},{"location":"classes_seva/#adapters-sevaadapters","title":"Adapters (<code>seva/adapters</code>)","text":""},{"location":"classes_seva/#shared-transport-and-error-handling","title":"Shared transport and error handling","text":"<ul> <li><code>http_client.py</code>: <code>RetryingSession</code> and <code>HttpConfig</code> centralize API-key headers, timeout policy, retry loops, and multipart reset behavior before upload retries.</li> <li><code>api_errors.py</code>: typed adapter error hierarchy (<code>ApiClientError</code>, <code>ApiServerError</code>, <code>ApiTimeoutError</code>) plus payload parsing helpers consumed by use-case error mapping (<code>seva/usecases/error_mapping.py</code>).</li> </ul>"},{"location":"classes_seva/#rest-adapters-implementing-ports","title":"REST adapters implementing ports","text":"<ul> <li><code>job_rest.py</code> (<code>JobPort</code>): implements run lifecycle transport and payload mapping.</li> <li>consumed by <code>StartExperimentBatch</code>, <code>PollGroupStatus</code>, <code>CancelGroup</code>, <code>CancelRuns</code>, and <code>DownloadGroupResults</code> (wired in <code>seva/app/controller.py</code>)</li> <li>translates <code>ExperimentPlan</code> wells into <code>POST /jobs</code> payloads (<code>devices</code>, <code>modes</code>, <code>params_by_mode</code>, metadata)</li> <li>polls <code>POST /jobs/status</code> and returns server-authoritative snapshot dictionaries for domain normalization</li> <li>downloads <code>GET /runs/{run_id}/zip</code> artifacts and writes grouped ZIP files under <code>&lt;target&gt;/&lt;group&gt;/&lt;box&gt;/</code></li> <li>raises typed adapter errors from <code>seva/adapters/api_errors.py</code></li> <li><code>device_rest.py</code> (<code>DevicePort</code>): implements metadata and capability reads.</li> <li>consumed by <code>TestConnection</code> and <code>PollDeviceStatus</code></li> <li>calls <code>/health</code>, <code>/devices</code>, <code>/devices/status</code>, <code>/modes</code>, <code>/modes/{mode}/params</code></li> <li>normalizes mode keys and caches mode lists/schemas per box</li> <li>raises typed adapter errors from <code>seva/adapters/api_errors.py</code></li> <li><code>firmware_rest.py</code> (<code>FirmwarePort</code>): implements binary upload to <code>/firmware/flash</code>.</li> <li>consumed by <code>FlashFirmware</code></li> <li>performs multipart upload with shared retry/timeout policy</li> <li>raises typed adapter errors from <code>seva/adapters/api_errors.py</code></li> <li><code>update_rest.py</code> (<code>UpdatePort</code>): implements package-update upload and status polling.</li> <li>consumed by <code>StartRemoteUpdate</code> and <code>PollRemoteUpdate</code></li> <li>uploads <code>.zip</code> package to <code>POST /updates/package</code> and polls <code>GET /updates/{update_id}</code></li> <li>raises typed adapter errors from <code>seva/adapters/api_errors.py</code></li> <li><code>discovery_http.py</code> (<code>DeviceDiscoveryPort</code>): implements host/base-url/CIDR discovery.</li> <li>consumed by <code>DiscoverDevices</code> and <code>DiscoverAndAssignDevices</code></li> <li>expands CIDR ranges, probes <code>/version</code> for identity and <code>/health</code> for enrichment</li> <li>deduplicates discovered <code>base_url</code> values before returning domain <code>DiscoveredBox</code> objects</li> </ul>"},{"location":"classes_seva/#localtest-adapters","title":"Local/test adapters","text":"<ul> <li><code>storage_local.py</code> (<code>StoragePort</code>): JSON persistence for layouts and user settings.</li> <li>consumed by <code>SavePlateLayout</code>, <code>LoadPlateLayout</code>, <code>RunFlowCoordinator</code> registry/settings interactions, and app/settings/discovery controllers</li> <li>enforces <code>layout_*.json</code> naming and uses atomic write (<code>tempfile</code> + <code>os.replace</code>) for <code>user_settings.json</code></li> <li><code>job_rest_mock.py</code>: in-memory <code>JobPort</code> implementation for offline tests and deterministic run-state simulation.</li> <li><code>relay_mock.py</code>: stub <code>RelayPort</code> implementation consumed by <code>TestRelay</code> and <code>SetElectrodeMode</code> in non-hardware environments.</li> </ul>"},{"location":"classes_seva/#usecases-sevausecases","title":"UseCases (<code>seva/usecases</code>)","text":""},{"location":"classes_seva/#plan-and-metadata-construction","title":"Plan and metadata construction","text":"<ul> <li><code>build_experiment_plan.py</code>: builds typed <code>ExperimentPlan</code> from UI snapshots.</li> <li><code>build_storage_meta.py</code>: derives <code>StorageMeta</code> used for artifact output paths.</li> </ul>"},{"location":"classes_seva/#runtime-orchestration","title":"Runtime orchestration","text":"<ul> <li><code>start_experiment_batch.py</code>: submits plan via <code>JobPort</code>.</li> <li><code>poll_group_status.py</code>: returns normalized, server-authoritative <code>GroupSnapshot</code>.</li> <li><code>download_group_results.py</code>: downloads and unpacks run artifacts.</li> <li><code>cancel_group.py</code> / <code>cancel_runs.py</code>: run cancellation orchestration.</li> <li><code>run_flow_coordinator.py</code>: stateful start/poll/download coordination with hooks.</li> </ul>"},{"location":"classes_seva/#discovery-and-diagnostics","title":"Discovery and diagnostics","text":"<ul> <li><code>discover_devices.py</code>: candidate probing and registry merge helpers.</li> <li><code>discover_and_assign_devices.py</code>: combined discovery + assignment operation.</li> <li><code>poll_device_status.py</code>: per-channel status snapshots for activity UI.</li> <li><code>test_connection.py</code>: health + device diagnostics for a box.</li> <li><code>test_relay.py</code>, <code>set_electrode_mode.py</code>: relay diagnostics/configuration.</li> <li><code>start_remote_update.py</code>: starts package update uploads across configured boxes.</li> <li><code>poll_remote_update.py</code>: polls package update status across configured boxes.</li> </ul>"},{"location":"classes_seva/#layout-and-persistence-workflows","title":"Layout and persistence workflows","text":"<ul> <li><code>save_plate_layout.py</code> / <code>load_plate_layout.py</code>: plate snapshot persistence and restore.</li> <li><code>apply_ir_correction.py</code>: reserved placeholder for future post-processing.</li> <li><code>error_mapping.py</code>: central adapter-to-usecase error translation.</li> </ul>"},{"location":"classes_seva/#viewmodels-sevaviewmodels","title":"ViewModels (<code>seva/viewmodels</code>)","text":"<ul> <li><code>experiment_vm.py</code> (<code>ExperimentVM</code>)</li> <li>bound view: <code>seva/app/views/experiment_panel_view.py</code></li> <li>app wiring: <code>App._on_apply_params</code>, <code>App._on_copy_mode</code>, <code>App._on_paste_mode</code>, <code>App._on_selection_changed</code></li> <li>usecase dependency (read-only): <code>RunFlowPresenter._build_plan_request</code> consumes <code>well_params</code> snapshots</li> <li>state owned: flat live form (<code>fields</code>), grouped per-well snapshots (<code>well_params</code>), mode clipboards</li> <li><code>plate_vm.py</code> (<code>PlateVM</code>)</li> <li>bound view: <code>seva/app/views/well_grid_view.py</code></li> <li>app wiring: selection callback to <code>App._on_selection_changed</code>; command intents to app methods</li> <li>usecase dependency (indirect): <code>RunFlowPresenter</code> reads <code>configured()</code> and <code>get_selection()</code> for start/cancel payloads</li> <li>state owned: selected wells, configured wells, box-prefix helpers</li> <li><code>progress_vm.py</code> (<code>ProgressVM</code>)</li> <li>bound views: <code>seva/app/views/run_overview_view.py</code>, <code>seva/app/views/channel_activity_view.py</code></li> <li>app wiring: callbacks <code>App._apply_run_overview</code> and <code>App._apply_channel_activity</code></li> <li>usecase dependency: consumes <code>GroupSnapshot</code> from <code>PollGroupStatus</code>; consumes <code>DeviceActivitySnapshot</code> from <code>PollDeviceStatus</code></li> <li>state owned: active group id, last snapshot cache, derived well/box/activity DTOs</li> <li><code>runs_vm.py</code> (<code>RunsVM</code>)</li> <li>bound view: <code>seva/app/views/runs_panel_view.py</code></li> <li>app wiring: <code>RunFlowPresenter._refresh_runs_panel</code> and selection sync</li> <li>usecase dependency: projects <code>RunsRegistry</code> entries that are fed by <code>RunFlowCoordinator</code> events</li> <li>state owned: currently active group id for runs panel</li> <li><code>settings_vm.py</code> (<code>SettingsVM</code>, <code>SettingsConfig</code>)</li> <li>bound view/controller: <code>seva/app/settings_controller.py</code> + <code>SettingsDialog</code></li> <li>app wiring: loaded at startup in <code>App._load_user_settings</code>; consumed by <code>AppController.ensure_ready</code></li> <li>usecase dependency: parameters passed into <code>BuildStorageMeta</code>, <code>StartExperimentBatch</code>, polling cadence, diagnostics, discovery, remote update upload path</li> <li>state owned: typed runtime config, API URLs/keys, dialog-only fields (<code>experiment_name</code>, <code>subdir</code>, relay/debug flags, <code>update_package_path</code>)</li> <li><code>live_data_vm.py</code> (<code>LiveDataVM</code>)</li> <li>bound view: standalone plotter (<code>seva/app/dataplotter_standalone.py</code>)</li> <li>usecase dependency: none currently; reserved for future post-processing workflows</li> <li>state owned: include toggles per well, axes, section filter, IR correction text</li> <li><code>status_format.py</code></li> <li>pure helper module used by <code>ProgressVM</code> and <code>RunsVM</code></li> <li>responsibility: normalize/label run phases so views never hardcode status-text mapping</li> </ul>"},{"location":"classes_seva/#app-and-views-sevaapp-sevaappviews","title":"App and Views (<code>seva/app</code>, <code>seva/app/views</code>)","text":""},{"location":"classes_seva/#app-composition-and-controllers","title":"App composition and controllers","text":"<ul> <li><code>main.py</code>: application bootstrap and top-level event wiring.</li> <li><code>controller.py</code>: adapter/use-case construction based on settings.</li> <li><code>run_flow_presenter.py</code>: UI-facing orchestration glue for start/cancel/poll/download.</li> <li><code>settings_controller.py</code>, <code>download_controller.py</code>, <code>discovery_controller.py</code>: dialog/action specific controllers.</li> <li><code>polling_scheduler.py</code>: scheduler abstraction for group polling timers.</li> <li><code>nas_gui_smb.py</code>: standalone NAS setup helper UI.</li> </ul>"},{"location":"classes_seva/#view-modules","title":"View modules","text":"<ul> <li><code>views/main_window.py</code>: top-level window and toolbar/tab layout.</li> <li><code>views/well_grid_view.py</code>: plate grid widget and selection interactions.</li> <li><code>views/experiment_panel_view.py</code>: mode parameter editor panel.</li> <li><code>views/run_overview_view.py</code>: per-box and per-well progress display.</li> <li><code>views/channel_activity_view.py</code>: channel activity visualization.</li> <li><code>views/runs_panel_view.py</code>: run-group table with actions.</li> <li><code>views/settings_dialog.py</code>: settings modal UI.</li> <li><code>views/discovery_results_dialog.py</code>: discovery result display dialog.</li> </ul>"},{"location":"codex_guide/","title":"ChatGPT Codex User Guide (SEVA GUI MVVM)","text":"<p>This document is a formal guide for developers who want to use ChatGPT Codex effectively in this repository.</p> <p>It focuses on practical collaboration: selecting the correct repository context, planning work, implementing safely, validating changes, and iterating through pull requests.</p>"},{"location":"codex_guide/#1-repository-context-and-governing-documents","title":"1. Repository Context and Governing Documents","text":""},{"location":"codex_guide/#11-read-agentsmd-first-required","title":"1.1 Read <code>AGENTS.md</code> first (required)","text":"<p>Before requesting code changes, read <code>AGENTS.md</code> once to understand repository guardrails. It already covers:</p> <ul> <li>MVVM + Hexagonal layer boundaries,</li> <li>domain objects vs. raw dict/JSON above adapters,</li> <li>error propagation policy,</li> <li>avoidance of legacy fallback paths,</li> <li>testing direction.</li> </ul> <p>Because this is already documented centrally, you do not need to restate all architecture boundaries in every prompt.</p>"},{"location":"codex_guide/#12-use-agentplansmd-when-needed-optional-situation-dependent","title":"1.2 Use <code>.agent/PLANS.md</code> when needed (optional, situation-dependent)","text":"<p>Reading <code>.agent/PLANS.md</code> is optional for small or straightforward work.</p> <p>Use it when work is large, cross-cutting, risky, or unclear (for example major refactors, architecture-impacting features, or complex migrations).</p>"},{"location":"codex_guide/#13-update-guardrails-over-time-recommended","title":"1.3 Update guardrails over time (recommended)","text":"<p>It can be useful to refine <code>AGENTS.md</code> as team understanding evolves, for example:</p> <ul> <li>before a large refactor,</li> <li>after long periods without updates,</li> <li>when recurring review issues appear.</li> </ul>"},{"location":"codex_guide/#2-quickstart-workflow-web","title":"2. Quickstart Workflow (Web)","text":"<p>Use this operational flow when working with Codex in the web interface.</p> <ol> <li>Select repository and target branch.</li> <li>Ask your implementation or analysis question.</li> <li>Review generated plan and code changes.</li> <li>Let Codex create a pull request.</li> <li>Test the branch independently.</li> <li>Decide next action:</li> <li>merge branch,</li> <li>make additional manual commits,</li> <li>or continue improving with Codex and update the branch.</li> </ol> <p>This workflow should be your default working model.</p>"},{"location":"codex_guide/#3-prompting-standard-required-vs-optional-inputs","title":"3. Prompting Standard: Required vs Optional Inputs","text":"<p>Use this structure to communicate with Codex.</p>"},{"location":"codex_guide/#31-required","title":"3.1 Required","text":"<ul> <li>Goal/outcome: what should work after the change?</li> <li>Scope/context: which files, modules, or user flows are relevant?</li> <li>Constraints/non-goals: what must remain unchanged?</li> </ul>"},{"location":"codex_guide/#32-optional-but-helpful","title":"3.2 Optional but helpful","text":"<ul> <li>touched files to prioritize,</li> <li>risk points to watch,</li> <li>validation strategy expectations,</li> <li>requirement that Codex asks clarifying questions before implementation.</li> </ul> <p>Recommended instruction to include when requirements are unclear:</p> <ul> <li>\u201cBefore implementing, ask clarifying questions until ambiguity is low.\u201d</li> </ul>"},{"location":"codex_guide/#4-practical-task-workflows","title":"4. Practical Task Workflows","text":""},{"location":"codex_guide/#41-bugfix-workflow","title":"4.1 Bugfix Workflow","text":"<p>Start from evidence first:</p> <ul> <li>provide a GUI screenshot,</li> <li>provide a terminal screenshot,</li> <li>or paste direct terminal output.</li> </ul> <p>Then work iteratively with Codex:</p> <ul> <li>ask where Codex thinks the issue originates,</li> <li>request likely root causes and candidate fixes,</li> <li>if you already have hypotheses, provide them and refine direction together.</li> </ul> <p>Important practice note:</p> <ul> <li>Codex can sometimes produce symptom-level fixes (\u201cband-aid fixes\u201d).</li> <li>Ask explicitly for a deep/root-cause fix when needed.</li> <li>Final confidence still comes from testing and code familiarity.</li> </ul> <p>This pattern often works very well for smaller fixes.</p>"},{"location":"codex_guide/#42-refactor-workflow","title":"4.2 Refactor Workflow","text":"<p>For refactors, planning iterations are critical.</p> <p>Recommended approach:</p> <ul> <li>run multiple plan-review cycles before coding,</li> <li>ask Codex to ask questions and challenge assumptions,</li> <li>for larger refactors, optionally reference <code>.agent/PLANS.md</code>,</li> <li>ask to update affected documentation in <code>docs/</code> when behavior, workflows, or interfaces change.</li> </ul> <p>Important experience-based guidance:</p> <ul> <li>Codex may introduce unnecessary fallback paths.</li> <li>Codex may re-implement helpers that already exist.</li> </ul> <p>To reduce this risk, instruct explicitly:</p> <ul> <li>\u201cScan the relevant codebase deeply before proposing refactor steps.\u201d</li> <li>\u201cSearch for existing helpers/utilities before creating new ones.\u201d</li> <li>\u201cDo not introduce fallback branches unless explicitly required.\u201d</li> </ul>"},{"location":"codex_guide/#43-feature-implementation-workflow","title":"4.3 Feature Implementation Workflow","text":"<p>Feature work can start in two valid modes:</p> <ul> <li>exploratory mode: requirements are still vague,</li> <li>specified mode: architecture and expected flow are already known.</li> </ul> <p>If requirements are vague, use planning iterations to converge:</p> <ul> <li>start broad,</li> <li>refine design through questions/answers,</li> <li>then implement once direction is stable.</li> </ul> <p>If requirements are clear, provide explicit implementation guidance (layer ownership, contracts, validation).</p> <p>For feature work, keep documentation in <code>docs/</code> up to date whenever user-facing behavior, workflows, setup steps, or interfaces are changed. Use the same Chat to keep context.</p> <p>Global simplicity rule for feature work and refactors:</p> <ul> <li>apply YAGNI (You Aren't Gonna Need It: avoid building speculative functionality),</li> <li>apply KISS (Keep It Simple, Stupid: prefer the simplest solution that satisfies current requirements),</li> <li>apply DRY (Don't Repeat Yourself: reuse existing logic instead of duplicating behavior),</li> <li>ask Codex to review a broad file set during planning to avoid local optimization and overengineering.</li> </ul>"},{"location":"codex_guide/#5-common-failure-modes-in-practice","title":"5. Common Failure Modes in Practice","text":"<p>Watch for these recurring issues:</p> <ul> <li>implementing too quickly without clarifying uncertainty,</li> <li>solving symptoms instead of root causes,</li> <li>duplicating existing helpers/utilities,</li> <li>adding unnecessary fallback/legacy logic,</li> <li>overengineering simple requirements,</li> <li>validating too little before merge.</li> </ul> <p>When one of these appears, return to planning and request targeted clarification.</p>"},{"location":"codex_guide/#6-how-to-steer-codex-during-planning-iterations","title":"6. How to Steer Codex During Planning Iterations","text":"<p>Use concise steering instructions such as:</p> <ul> <li>\u201cPropose an initial plan and list open questions first.\u201d</li> <li>\u201cIdentify uncertainties and ask me what you need before coding.\u201d</li> <li>\u201cReview more files before finalizing architecture decisions.\u201d</li> <li>\u201cPrefer existing helpers over new abstractions when possible.\u201d</li> <li>\u201cPrioritize a deep fix over a temporary symptom patch.\u201d</li> <li>\u201cKeep solution simple (YAGNI/KISS/DRY), avoid overengineering.\u201d</li> </ul> <p>A short, explicit steering message is usually enough to improve output quality significantly.</p>"},{"location":"codex_guide/#7-decision-checklist-before-merge","title":"7. Decision Checklist Before Merge","text":"<p>Before merging a Codex-generated branch, confirm:</p> <ul> <li>[ ] behavior is correct in your own branch testing,</li> <li>[ ] no obvious fallback/legacy detours were introduced,</li> <li>[ ] existing helpers were reused where appropriate,</li> <li>[ ] complexity is justified and not overengineered,</li> <li>[ ] follow-up improvements are documented if needed.</li> </ul> <p>If these checks fail, iterate on the same branch with Codex or make targeted manual commits before merge.</p>"},{"location":"dev-setup/","title":"Development Setup","text":"<p>This guide focuses on developers who are familiar with Python but new to the SEVA codebase. It covers setting up the GUI (Windows/Linux) and running the REST API on Linux/Raspberry Pi.</p>"},{"location":"dev-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10\u20133.12</li> <li>Git</li> </ul>"},{"location":"dev-setup/#install-dependencies","title":"Install dependencies","text":"<p>From the repository root:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"dev-setup/#run-the-gui-windowslinux","title":"Run the GUI (Windows/Linux)","text":"<p>Start the Tkinter GUI locally with:</p> <pre><code>python -m seva.app.main\n</code></pre> <p>If you need a custom storage root (where the GUI reads/writes local files), set <code>SEVA_STORAGE_ROOT</code> before starting:</p> <pre><code>SEVA_STORAGE_ROOT=\"path/to/storage\" python -m seva.app.main\n</code></pre> <p>On Windows (PowerShell):</p> <pre><code>$env:SEVA_STORAGE_ROOT=\"path\\\\to\\\\storage\"\npython -m seva.app.main\n</code></pre>"},{"location":"dev-setup/#run-the-rest-api-linuxraspberry-pi","title":"Run the REST API (Linux/Raspberry Pi)","text":"<p>The REST API is intended to run on Linux/Raspberry Pi devices. On the Pi (or Linux host), start the FastAPI app from the directory where <code>rest_api/app.py</code> lives:</p> <pre><code>cd rest_api\nuvicorn app:app --host 0.0.0.0 --port 8000\n</code></pre> <p>For a full setup tutorial (installation, env vars, smoke tests, NAS/SMB checks, and restart procedures), see:</p> <ul> <li>REST API Setup Tutorial</li> </ul>"},{"location":"dev-setup/#rest-api-environment-variables-quick-reference","title":"REST API environment variables (quick reference)","text":"<ul> <li><code>RUNS_ROOT</code>: Root directory where run data is stored. Defaults to <code>/opt/box/runs</code>.</li> <li><code>BOX_API_KEY</code>: Optional API key for securing requests.</li> <li><code>BOX_ID</code>: Identifier for the box (used in health/device responses).</li> <li><code>NAS_CONFIG_PATH</code>: Optional path for NAS/SMB configuration persistence.</li> <li><code>BOX_BUILD</code> / <code>BOX_BUILD_ID</code>: Optional build metadata for versioning.</li> </ul> <p>Example:</p> <pre><code>RUNS_ROOT=\"/opt/box/runs\" BOX_ID=\"A\" uvicorn app:app --host 0.0.0.0 --port 8000\n</code></pre>"},{"location":"dev-setup/#next-steps","title":"Next steps","text":"<ul> <li>Review the Architecture Overview for MVVM + Hexagonal boundaries.</li> <li>Use SEVA GUI workflows and REST API workflows to navigate use cases.</li> <li>Check Troubleshooting for common issues.</li> </ul>"},{"location":"glossary/","title":"Glossary","text":"<p>This glossary mixes domain terms (runs, wells, boxes) with MVVM + Hexagonal architecture terms so new developers can reason about the system without prior framework knowledge. Each entry includes a short definition and a pointer to where the concept lives in code.</p>"},{"location":"glossary/#mvvm-hexagonal-terms","title":"MVVM + Hexagonal terms","text":"<p>View UI widgets and rendering logic only. Views expose callbacks and never perform I/O or business logic. See <code>seva/app/views/*</code>.</p> <p>ViewModel State + commands used by views. ViewModels coordinate UI state but do not touch adapters or build API payloads. See <code>seva/viewmodels/*</code>.</p> <p>UseCase Workflow orchestration that coordinates domain rules and adapters (e.g., save layout, start jobs, cancel runs). See <code>seva/usecases/*</code>.</p> <p>Adapter I/O boundary implementation for a port (HTTP, filesystem, relay, discovery). Adapters are called by use cases or controllers but never orchestrate flows. See <code>seva/adapters/*</code>.</p> <p>Port A protocol that defines the boundary between use cases and external systems. Adapters implement ports, and use cases depend on ports. See <code>seva/domain/ports.py</code>.</p> <p>Domain type Value objects that normalize and validate identifiers and snapshots early. See <code>seva/domain/entities.py</code> for <code>RunId</code>, <code>GroupId</code>, <code>WellId</code>, and more.</p>"},{"location":"glossary/#domain-terms","title":"Domain terms","text":"<p>Box A hardware enclosure (Pi + potentiostat) addressed by a <code>BoxId</code>. See <code>seva/domain/entities.py</code>.</p> <p>Run An individual experiment execution on the backend, identified by a <code>RunId</code>. See <code>seva/domain/entities.py</code>.</p> <p>Group A collection of related runs started together, identified by a <code>GroupId</code> (or <code>RunGroupId</code> in ports). See <code>seva/domain/entities.py</code> and <code>seva/domain/ports.py</code>.</p> <p>Well A plate position within a batch plan. Represented by <code>WellId</code>. See <code>seva/domain/entities.py</code>.</p> <p>Mode The electrochemistry mode applied to a well (e.g., CV, EIS). Mode tokens are normalized via domain utilities (see <code>seva/domain/modes.py</code>).</p> <p>Layout Saved plate configuration (selection + parameters) persisted locally by the storage adapter. See <code>seva/adapters/storage_local.py</code> and <code>seva/usecases/save_plate_layout.py</code>.</p>"},{"location":"glossary/#code-examples-mvvm-hexagonal-call-chain","title":"Code examples (MVVM + Hexagonal call chain)","text":""},{"location":"glossary/#view-viewmodel-callbacks","title":"View \u2192 ViewModel callbacks","text":"<p>Views receive callbacks that delegate to ViewModel commands (no I/O in views).</p> <pre><code>self.wellgrid = WellGridView(\n    self.win.wellgrid_host,\n    boxes=initial_boxes,\n    on_select_wells=lambda sel: self.plate_vm.set_selection(sel),\n    on_copy_params_from=lambda wid: self.plate_vm.cmd_copy_from(wid),\n    on_paste_params_to_selection=self.plate_vm.cmd_paste_to_selection,\n)\n</code></pre> <p>Source: <code>seva/app/main.py</code></p>"},{"location":"glossary/#usecase-port-adapter-boundary","title":"UseCase \u2192 Port (adapter boundary)","text":"<p>Use cases call ports to persist or fetch data. Ports are implemented by adapters.</p> <pre><code>return self.storage.save_layout(name, payload)\n</code></pre> <p>Source: <code>seva/usecases/save_plate_layout.py</code></p>"},{"location":"glossary/#adapter-implements-a-port","title":"Adapter implements a Port","text":"<p>Adapters implement port methods to perform I/O. This adapter writes JSON layouts to disk.</p> <pre><code>def save_layout(self, name: str, payload: Dict) -&gt; Path:\n    path = self._layout_path(name)\n    path.parent.mkdir(parents=True, exist_ok=True)\n    with path.open(\"w\", encoding=\"utf-8\") as fh:\n        json.dump(payload, fh, ensure_ascii=False, sort_keys=True, separators=(\",\", \":\"))\n    return path\n</code></pre> <p>Source: <code>seva/adapters/storage_local.py</code></p>"},{"location":"gui_overview_how_to_use/","title":"GUI Overview &amp; How to Use (End-User Tutorial)","text":"<p>This guide explains the SEVA GUI from an end-user perspective.</p> <ul> <li>Focus: what is where and what each function is for.</li> <li>Scope: complete workflow from setup to download.</li> <li>For architecture and code details, see Architecture Overview, SEVA GUI Workflows, and SEVA GUI Classes &amp; Modules.</li> </ul>"},{"location":"gui_overview_how_to_use/#1-main-window-orientation","title":"1) Main window orientation","text":"<p>The main window is your starting point.</p> <p></p>"},{"location":"gui_overview_how_to_use/#toolbar-top","title":"Toolbar (top)","text":"<ul> <li>Start: starts a new run group with the current plate/well configuration.</li> <li>Cancel Group: cancels the currently active run group.</li> <li>Save Layout / Load Layout: save or restore plate configuration presets.</li> <li>Settings: open connectivity, storage, timing, relay, package-update, and NAS options.</li> <li>Data Plotter: open the plotting tool for downloaded data.</li> </ul>"},{"location":"gui_overview_how_to_use/#tabs-right-side","title":"Tabs (right side)","text":"<ul> <li>Experiment: define CV / DC-AC / Cdl / EIS parameters.</li> <li>Run Overview: monitor group progress and trigger group download.</li> <li>Runs: browse completed/running groups and open their folders.</li> <li>Channel Activity: quick per-channel status view.</li> </ul>"},{"location":"gui_overview_how_to_use/#2-first-time-setup-required-before-starting-runs","title":"2) First-time setup (required before starting runs)","text":"<p>Open Settings from the toolbar.</p> <p></p>"},{"location":"gui_overview_how_to_use/#boxes","title":"Boxes","text":"<ul> <li>Enter Box A/B/C/D URL.</li> <li>Enter API Key (if required by your deployment).</li> <li>Use Test per box to verify connectivity.</li> <li>Use Scan Network to discover available devices automatically.</li> </ul> <p>Feature detail: discovery is not a blind scan only. The app uses your configured box URLs as discovery candidates and also derives subnet hints (for example <code>/24</code>) from those URLs, then deduplicates the candidate list before scanning.</p>"},{"location":"gui_overview_how_to_use/#relay-box","title":"Relay box","text":"<ul> <li>Configure relay controller IP and Port.</li> <li>Use Test Relay to verify relay communication.</li> </ul>"},{"location":"gui_overview_how_to_use/#timing","title":"Timing","text":"<ul> <li>Set request, polling, and download timeout values.</li> <li>Keep defaults unless your network/API behavior requires tuning.</li> </ul>"},{"location":"gui_overview_how_to_use/#storage","title":"Storage","text":"<ul> <li>Set local Results directory.</li> <li>Set Experiment name and optional subdirectory for organized output.</li> </ul>"},{"location":"gui_overview_how_to_use/#package-update","title":"Package update","text":"<ul> <li>Select an update <code>.zip</code> package and use Start Remote Update.</li> <li>The modal update dialog stays open until terminal status and shows backend step + heartbeat updates.</li> <li>To build valid packages, use the standalone generator script:</li> <li><code>py -3.13 StreamingStandalone/update_zip_generator.py</code></li> </ul>"},{"location":"gui_overview_how_to_use/#nas-advanced-optional","title":"NAS (advanced / optional)","text":"<ul> <li>Use Open NAS Setup... for SMB/NAS upload workflows.</li> </ul>"},{"location":"gui_overview_how_to_use/#flags","title":"Flags","text":"<ul> <li>Auto-download results on completion: downloads automatically when all runs finish.</li> <li>Use streaming (SSE/WebSocket): reserved toggle for streaming-capable deployments; default production run monitoring remains polling-based.</li> <li>Enable debug logging: increases log detail for diagnostics.</li> </ul> <p>Finish by pressing Save.</p> <p>Feature detail: saving settings performs validation first. The selected Results directory must exist and be writable, and the app shows an HTTPS warning dialog if box URLs use <code>https://</code> in environments that commonly run HTTP-only backend endpoints.</p>"},{"location":"gui_overview_how_to_use/#3-optional-discover-devices-from-the-network","title":"3) Optional: discover devices from the network","text":"<p>When you run network discovery, this result dialog shows detected SEVA devices.</p> <p></p> <p>Use this to confirm that expected boxes are reachable and to validate API/build information.</p>"},{"location":"gui_overview_how_to_use/#4-configure-wells-and-methods","title":"4) Configure wells and methods","text":""},{"location":"gui_overview_how_to_use/#41-select-wells-in-the-grid","title":"4.1 Select wells in the grid","text":"<p>Use the well grid to choose which channels/wells should run.</p> <p></p> <ul> <li>Reset Well Config: clears configuration for the currently selected well(s).</li> <li>Reset all Wells: clears the full plate configuration.</li> </ul> <p>Feature detail: the grid supports several interaction patterns. - Single click selects one well. - Shift+click toggles multi-selection. - Right-click opens a context menu with copy/paste/reset/enable-toggle/open-PNG actions for fast editing flows.</p>"},{"location":"gui_overview_how_to_use/#42-set-experiment-parameters","title":"4.2 Set experiment parameters","text":"<p>In the Experiment tab, define methods and parameters.</p> <p></p> <p>Available sections:</p> <ul> <li>Cyclic Voltammetry (CV)</li> <li>Electrolysis (DC/AC)</li> <li>Capacitance (Cdl)</li> <li>Impedance (EIS)</li> </ul> <p>Key actions:</p> <ul> <li>Enable/disable each method using its checkbox.</li> <li>Edit numeric parameters and control mode/targets where applicable.</li> <li>Update Parameters applies values to selected wells.</li> <li>End Selection ends the current selection workflow.</li> <li>End Task ends active task context from the panel.</li> </ul>"},{"location":"gui_overview_how_to_use/#5-start-and-monitor-a-run","title":"5) Start and monitor a run","text":""},{"location":"gui_overview_how_to_use/#51-start","title":"5.1 Start","text":"<p>From the toolbar, click Start.</p>"},{"location":"gui_overview_how_to_use/#52-run-overview-tab","title":"5.2 Run Overview tab","text":"<p>Use Run Overview to monitor active progress and status.</p> <p></p> <ul> <li>Top cards show status per box (A/B/C/D).</li> <li>Table shows per-well information (phase, mode, progress, remaining time, last error, sub-run ID).</li> <li>Download Group triggers a full group results download.</li> </ul> <p>Feature detail: if a row contains a long error message, double-click that row to open a full error dialog and copy the text (useful for support/tickets).</p>"},{"location":"gui_overview_how_to_use/#53-channel-activity-tab","title":"5.3 Channel Activity tab","text":"<p>Use Channel Activity for quick channel-state visibility.</p> <p></p>"},{"location":"gui_overview_how_to_use/#6-manage-run-history-and-download-folders","title":"6) Manage run history and download folders","text":"<p>In the Runs tab, manage existing run groups.</p> <p></p> <ul> <li>Open Folder: opens the selected run group directory.</li> <li>Cancel: requests cancel for selected running group.</li> <li>Delete: removes selected row(s) from the list/history view.</li> </ul> <p>Feature detail: - Action buttons are enabled only when a row is selected. - Cancel/Delete actions include confirmation dialogs in active-run cases. - This tab is intended for post-start run lifecycle management (open, cancel, remove history entries).</p> <p>Table columns include group ID, name, status, progress, boxes, start time, and download path.</p>"},{"location":"gui_overview_how_to_use/#7-plot-and-export-data","title":"7) Plot and export data","text":"<p>Open Data Plotter from the toolbar after data is available locally.</p> <p></p> <p>Typical use:</p> <ol> <li>Select your CSV input.</li> <li>Choose axis options and optional integration controls.</li> <li>Apply optional IR correction.</li> <li>Save/export the resulting data/plots.</li> </ol> <p>This view is focused on plotting and export operations from already downloaded data.</p>"},{"location":"gui_overview_how_to_use/#8-optional-advanced-workflow-nas-setup","title":"8) Optional advanced workflow: NAS setup","text":"<p>Use NAS setup if your process requires SMB upload/retention handling.</p> <p></p> <p>Typical fields:</p> <ul> <li>API connection (Base URL + API key)</li> <li>SMB host/share/credentials</li> <li>Retention days</li> <li>Manual upload by run ID</li> <li>Health checks and server response panel</li> </ul> <p>Use this only when your lab flow includes NAS archiving.</p>"},{"location":"gui_overview_how_to_use/#9-typical-end-to-end-workflow-quick-checklist","title":"9) Typical end-to-end workflow (quick checklist)","text":"<ol> <li>Open Settings and configure box URLs/API keys.</li> <li>Test connectivity (and relay if used).</li> <li>Set results directory and save settings.</li> <li>Select wells in Well Grid.</li> <li>Configure methods in Experiment and apply parameters.</li> <li>Click Start.</li> <li>Monitor in Run Overview and Channel Activity.</li> <li>Download via Download Group (or auto-download).</li> <li>Open files in Runs tab.</li> <li>Optional: inspect/export in Data Plotter.</li> </ol> <p>If anything fails, see Troubleshooting.</p>"},{"location":"mvvm_tutorial_notebooks/","title":"MVVM + Hexagonal Tutorial Notebooks","text":"<p>To make the architecture easier to learn hands-on, this repository includes two tutorial notebooks in <code>docs/</code>.</p> <p>They are written as a guided sequence and complement the architecture/workflow docs.</p>"},{"location":"mvvm_tutorial_notebooks/#recommended-reading-order","title":"Recommended reading order","text":"<ol> <li> <p><code>docs/mvvm_hexagonal_intro.ipynb</code>    Introduces the core ideas behind MVVM + Hexagonal design in this project: layer boundaries, dependency direction, and why orchestration belongs in UseCases.</p> </li> <li> <p><code>docs/mvvm_hexagonal_part2_view_viewmodel.ipynb</code>    Continues with concrete View/ViewModel collaboration patterns, including command/state flow and where UI responsibilities stop.</p> </li> </ol>"},{"location":"mvvm_tutorial_notebooks/#how-to-use-them-with-the-docs","title":"How to use them with the docs","text":"<ul> <li>Read Architecture Overview first for the compact system map.</li> <li>Then work through the notebooks in order for a guided walkthrough.</li> <li>Afterwards, jump to:</li> <li>SEVA GUI Workflows for end-to-end GUI flows</li> <li>REST API Workflows for the server-side lifecycle</li> </ul>"},{"location":"mvvm_tutorial_notebooks/#notes-for-contributors","title":"Notes for contributors","text":"<p>When architecture behavior changes (for example, where validation lives or how UseCases orchestrate status polling), keep the notebooks aligned with:</p> <ul> <li><code>docs/architecture_overview.md</code></li> <li><code>docs/workflows_seva.md</code></li> <li><code>docs/workflows_rest_api.md</code></li> </ul> <p>This keeps the conceptual tutorial and implementation docs consistent.</p>"},{"location":"rest-api-setup/","title":"REST API Setup Tutorial (Linux/Raspberry Pi)","text":"<p>This guide focuses on setting up and operating the FastAPI service in <code>rest_api/</code>.</p> <p>Use this page if you want to:</p> <ul> <li>install a fresh REST API environment,</li> <li>configure runtime variables safely,</li> <li>run health checks before connecting the GUI,</li> <li>and run the API as a persistent systemd autostart service.</li> </ul>"},{"location":"rest-api-setup/#1-platform-and-prerequisites","title":"1) Platform and prerequisites","text":"<p>Recommended target: Linux/Raspberry Pi.</p> <ul> <li>Python &gt;=3.10</li> <li>Git</li> <li>Network access for dependency install (or a prepared offline wheelhouse)</li> </ul> <p>For NAS/SMB workflows, Linux system tools are also required:</p> <ul> <li><code>mount</code> with CIFS support (<code>cifs-utils</code> package on many distros)</li> <li><code>rsync</code></li> </ul>"},{"location":"rest-api-setup/#2-install-dependencies","title":"2) Install dependencies","text":"<p>From repository root:</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install -U pip\npip install -r requirements.txt\n</code></pre>"},{"location":"rest-api-setup/#reproducible-pybeep-installs-offlinevendor-note","title":"Reproducible pyBEEP installs (offline/vendor note)","text":"<p><code>requirements.txt</code> currently pins pyBEEP from a Git URL. For environments without internet access, vendor pyBEEP in-repo and install it from a local path (the file already contains a commented local editable example).</p>"},{"location":"rest-api-setup/#3-configure-environment-variables","title":"3) Configure environment variables","text":"<p>The API reads configuration from environment variables at startup.</p> <ul> <li><code>BOX_API_KEY</code> (optional): if set, every protected request must send   <code>X-API-Key</code>.</li> <li><code>BOX_ID</code> (optional): identifier returned by <code>/health</code>.</li> <li><code>RUNS_ROOT</code> (optional): run output root directory, default <code>/opt/box/runs</code>.</li> <li><code>NAS_CONFIG_PATH</code> (optional): SMB config path,   default <code>/opt/box/nas_smb.json</code>.</li> <li><code>BOX_BUILD</code> / <code>BOX_BUILD_ID</code> (optional): build metadata for <code>/version</code>.</li> </ul>"},{"location":"rest-api-setup/#a-variables-for-interactive-terminal-runs","title":"A) Variables for interactive terminal runs","text":"<pre><code>export BOX_API_KEY=\"change-me\"\nexport BOX_ID=\"lab-box-01\"\nexport RUNS_ROOT=\"/opt/box/runs\"\nexport NAS_CONFIG_PATH=\"/opt/box/nas_smb.json\"\n</code></pre>"},{"location":"rest-api-setup/#b-variables-for-systemd-service-runs-recommended","title":"B) Variables for systemd service runs (recommended)","text":"<p>Create an environment file that systemd can load:</p> <pre><code>sudo install -d -m 0755 /etc/seva\nsudo tee /etc/seva/box-api.env &gt;/dev/null &lt;&lt;'ENV'\nBOX_API_KEY=change-me\nBOX_ID=lab-box-01\nRUNS_ROOT=/opt/box/runs\nNAS_CONFIG_PATH=/opt/box/nas_smb.json\nBOX_BUILD=dev\nBOX_BUILD_ID=local\nENV\nsudo chmod 600 /etc/seva/box-api.env\n</code></pre> <p><code>EnvironmentFile=</code> is the most reliable way to \u201csend\u201d environment variables to systemd-managed services.</p>"},{"location":"rest-api-setup/#4-start-the-rest-api-manually-foreground","title":"4) Start the REST API manually (foreground)","text":"<p>Run from the REST API directory:</p> <pre><code>cd rest_api\nuvicorn app:app --host 0.0.0.0 --port 8000\n</code></pre> <p>Interactive OpenAPI docs are available at:</p> <ul> <li><code>http://&lt;host&gt;:8000/docs</code></li> </ul>"},{"location":"rest-api-setup/#5-configure-systemd-autostart-service","title":"5) Configure systemd autostart service","text":"<p>If you want the API to survive reboot and run automatically, create a systemd unit.</p>"},{"location":"rest-api-setup/#a-create-service-file","title":"A) Create service file","text":"<pre><code>sudo tee /etc/systemd/system/pybeep-box.service &gt;/dev/null &lt;&lt;'UNIT'\n[Unit]\nDescription=SEVA / pyBEEP Box REST API\nAfter=network-online.target\nWants=network-online.target\n\n[Service]\nType=simple\nUser=root\nGroup=root\nWorkingDirectory=&lt;REPOSITORY_PATH&gt;/rest_api\nEnvironmentFile=/etc/seva/box-api.env\nExecStart=&lt;VENV_PATH&gt;/.venv/bin/uvicorn app:app --host 0.0.0.0 --port 8000\nRestart=on-failure\nRestartSec=3\n\n[Install]\nWantedBy=multi-user.target\nUNIT\n</code></pre> <p>Adjust <code>User</code>, <code>Group</code>, <code>WorkingDirectory</code>, and <code>ExecStart</code> paths to match your installation. (Optional) Keep <code>User</code> and <code>Group</code> as <code>root</code> if you are unsure about your permissions.</p>"},{"location":"rest-api-setup/#b-enable-and-start-autostart","title":"B) Enable and start autostart","text":"<pre><code>sudo systemctl daemon-reload\nsudo systemctl enable pybeep-box.service\nsudo systemctl start pybeep-box.service\n</code></pre>"},{"location":"rest-api-setup/#c-verify-and-inspect-logs","title":"C) Verify and inspect logs","text":"<pre><code>sudo systemctl status pybeep-box.service --no-pager\nsudo journalctl -u pybeep-box.service -f\n</code></pre>"},{"location":"rest-api-setup/#d-update-environment-variables-later","title":"D) Update environment variables later","text":"<p>After editing <code>/etc/seva/box-api.env</code>, reload and restart:</p> <pre><code>sudo systemctl daemon-reload\nsudo systemctl restart pybeep-box.service\n</code></pre>"},{"location":"rest-api-setup/#6-smoke-test-after-startup","title":"6) Smoke test after startup","text":"<p>Use these checks before connecting the GUI.</p> <p>Without API key:</p> <pre><code>curl http://localhost:8000/health\ncurl http://localhost:8000/devices\ncurl http://localhost:8000/modes\n</code></pre> <p>With API key:</p> <pre><code>curl -H \"X-API-Key: $BOX_API_KEY\" http://localhost:8000/health\ncurl -H \"X-API-Key: $BOX_API_KEY\" http://localhost:8000/devices\ncurl -H \"X-API-Key: $BOX_API_KEY\" http://localhost:8000/modes\n</code></pre> <p>If you use systemd with <code>EnvironmentFile=</code>, your shell may not have <code>$BOX_API_KEY</code>. In that case, send the key explicitly:</p> <pre><code>curl -H \"X-API-Key: change-me\" http://localhost:8000/health\n</code></pre>"},{"location":"rest-api-setup/#7-restarting-the-rest-api","title":"7) Restarting the REST API","text":""},{"location":"rest-api-setup/#a-if-running-in-a-terminal","title":"A) If running in a terminal","text":"<ol> <li>Stop the server with <code>Ctrl+C</code>.</li> <li>Ensure your virtualenv/environment variables are still active.</li> <li>Start again:</li> </ol> <pre><code>cd rest_api\nuvicorn app:app --host 0.0.0.0 --port 8000\n</code></pre>"},{"location":"rest-api-setup/#b-if-running-as-a-systemd-service","title":"B) If running as a <code>systemd</code> service","text":"<pre><code>sudo systemctl restart pybeep-box.service\nsudo systemctl status pybeep-box.service --no-pager\n</code></pre> <p>Optional live logs:</p> <pre><code>sudo journalctl -u pybeep-box.service -f\n</code></pre>"},{"location":"rest-api-setup/#8-optional-nassmb-setup-check-linux","title":"8) Optional NAS/SMB setup check (Linux)","text":"<p>Configure once:</p> <pre><code>curl -X POST http://localhost:8000/nas/setup \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-API-Key: $BOX_API_KEY\" \\\n  -d '{\n        \"host\": \"nas.local\",\n        \"share\": \"experiments\",\n        \"username\": \"lab\",\n        \"password\": \"***\",\n        \"base_subdir\": \"projectA/line2\",\n        \"retention_days\": 14\n      }'\n</code></pre> <p>Check connectivity:</p> <pre><code>curl -H \"X-API-Key: $BOX_API_KEY\" http://localhost:8000/nas/health\n</code></pre>"},{"location":"rest-api-setup/#9-related-docs","title":"9) Related docs","text":"<ul> <li>Development Setup for overall GUI + API onboarding.</li> <li>REST API Workflows for end-to-end request flows.</li> <li>Troubleshooting for common issues and logging tips.</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>This page lists common issues when working with the GUI and the REST API, along with quick fixes and where to look for logs.</p> <p>For the full end-user workflow, see GUI Overview &amp; How to Use.</p>"},{"location":"troubleshooting/#nothing-discovered","title":"Nothing discovered","text":"<p>If device discovery returns nothing:</p> <ol> <li>Verify the REST API is running on the target device.</li> <li>In the GUI Settings, confirm the base URL/IP and port are correct.</li> <li>Use Test Connection to verify <code>/health</code> and <code>/devices</code> respond.</li> <li>On the Pi, ensure devices are attached and recognized by the OS.</li> </ol> <p>Note: discovery uses existing configured box URLs plus derived subnet hints. If your configured URLs are outdated, discovery quality will also be poor.</p>"},{"location":"troubleshooting/#wrong-base-url-api-not-reachable","title":"Wrong base URL / API not reachable","text":"<p>Symptoms: errors on startup, failed polls, or \"connection refused\".</p> <ul> <li>Check the GUI Settings \u2192 API base URL/IP for each box.</li> <li>Confirm the API is reachable from the GUI host:</li> </ul> <pre><code>curl http://&lt;box-ip&gt;:8000/health\n</code></pre>"},{"location":"troubleshooting/#run-does-not-start","title":"Run does not start","text":"<p>Common causes:</p> <ul> <li>No wells selected in the Well Grid.</li> <li>Method checkboxes not enabled in the Experiment panel.</li> <li>Missing/invalid parameter values for enabled method sections.</li> <li>Connectivity issue on one or more configured boxes.</li> </ul> <p>Quick checks:</p> <ol> <li>Open Settings and run Test for each active box.</li> <li>Confirm at least one well is selected.</li> <li>Confirm at least one method (CV/DC-AC/Cdl/EIS) is enabled where required.</li> <li>Try again with Enable debug logging turned on.</li> </ol>"},{"location":"troubleshooting/#progress-appears-stuck","title":"Progress appears stuck","text":"<p>If progress does not update:</p> <ol> <li>Verify network/API reachability again (<code>/health</code>).</li> <li>Check if streaming is enabled but unsupported in your environment; toggle Use streaming (SSE/WebSocket).</li> <li>Increase polling interval/timeout values in Settings \u2192 Timing if your network is slow.</li> <li>Watch server logs for long-running backend operations.</li> </ol>"},{"location":"troubleshooting/#download-did-not-appear","title":"Download did not appear","text":"<p>If runs complete but no files are visible:</p> <ol> <li>Confirm Results directory in Settings points to a writable location.</li> <li>If auto-download is disabled, use Run Overview \u2192 Download Group manually.</li> <li>Check the Runs tab <code>Download Path</code> column.</li> <li>Ensure local security software is not blocking folder creation.</li> </ol> <p>Tip: in Run Overview, double-click rows with errors to open the full error text and copy it for incident reports.</p>"},{"location":"troubleshooting/#settings-cannot-be-saved","title":"Settings cannot be saved","text":"<p>If pressing Save in Settings appears to do nothing or shows an error:</p> <ol> <li>Verify that the configured Results directory exists.</li> <li>Verify that your user has write permissions in that directory.</li> <li>Review HTTPS warnings carefully (for many deployments, backend URLs are HTTP-only).</li> <li>After correcting values, save again.</li> </ol>"},{"location":"troubleshooting/#downloads-do-not-open-the-folder","title":"Downloads do not open the folder","text":"<p>Depending on OS policies, the \"open folder\" action might be blocked.</p> <ul> <li>Windows: ensure the Results directory exists and is writable.</li> <li>Linux: confirm that the default file manager is available for your desktop   environment.</li> <li>If the folder does not open, manually navigate to the Results directory and   verify files were downloaded.</li> </ul>"},{"location":"troubleshooting/#nas-setup-common-problems-advancedoptional","title":"NAS setup: common problems (advanced/optional)","text":""},{"location":"troubleshooting/#nas-health-fails","title":"NAS Health fails","text":"<ul> <li>Verify NAS host/IP is reachable from the GUI machine.</li> <li>Verify SMB share name, username/password, and optional domain.</li> <li>Confirm firewall rules allow SMB traffic.</li> <li>Confirm API connection fields (Base URL/API key) are valid.</li> </ul>"},{"location":"troubleshooting/#upload-queue-succeeds-but-files-are-missing-on-nas","title":"Upload queue succeeds but files are missing on NAS","text":"<ul> <li>Check <code>Base Subdir</code> and retention configuration for path expectations.</li> <li>Verify the run ID exists and has local downloaded data.</li> <li>Re-run a manual upload with a known-good run ID.</li> </ul>"},{"location":"troubleshooting/#authentication-errors","title":"Authentication errors","text":"<ul> <li>Re-enter credentials carefully (including domain format if needed).</li> <li>Test SMB credentials outside the GUI if possible.</li> <li>Ensure account permission includes write access to the selected share.</li> </ul>"},{"location":"troubleshooting/#logging-debug-output","title":"Logging &amp; debug output","text":""},{"location":"troubleshooting/#gui-debug-logging","title":"GUI debug logging","text":"<p>Enable Settings \u2192 Enable debug logging to increase verbosity for the GUI.</p> <p>You can also force logging levels via environment variables:</p> <ul> <li><code>SEVA_LOG_LEVEL</code> / <code>SEVA_GUI_LOG_LEVEL</code> (explicit level like <code>DEBUG</code>)</li> <li><code>SEVA_DEBUG_LOGGING</code> / <code>SEVA_GUI_DEBUG</code> / <code>SEVA_DEBUG</code> (truthy \u2192 DEBUG)</li> </ul>"},{"location":"troubleshooting/#rest-api-logging","title":"REST API logging","text":"<p>Use <code>uvicorn</code> with the default logging output or increase verbosity via:</p> <pre><code>uvicorn app:app --host 0.0.0.0 --port 8000 --log-level debug\n</code></pre> <p>If you need more detail, check the system logs on the Pi host.</p>"},{"location":"workflows_rest_api/","title":"REST API Workflows","text":"<p>This document captures the end-to-end workflows that GUI code triggers in the REST API.</p> <p>For installation, environment variables, startup checks, and restart procedures, see REST API Setup Tutorial.</p>"},{"location":"workflows_rest_api/#tldr","title":"TL;DR","text":"<ul> <li>Default GUI run start uses <code>POST /jobs</code> (one run per planned well).</li> <li>Polling uses <code>POST /jobs/status</code> and optionally <code>GET /jobs/{run_id}</code>.</li> <li>Server snapshots (<code>job_snapshot</code>) are authoritative for <code>progress_pct</code> and <code>remaining_s</code>.</li> <li>Download/export uses <code>GET /runs/{run_id}/zip</code> (plus file endpoints where needed).</li> <li><code>POST /modes/{mode}/validate</code> exists for explicit pre-flight checks, but is not required in the current default start path.</li> <li>Remote package update uses <code>POST /updates/package</code> and <code>GET /updates/{update_id}</code>.</li> </ul>"},{"location":"workflows_rest_api/#terminology-used-on-this-page","title":"Terminology used on this page","text":"<ul> <li>run_id: identifier for one backend job/run.</li> <li>group_id: client grouping token used to correlate related runs.</li> <li>job: backend run record represented by <code>JobStatus</code>.</li> <li>snapshot: status view returned by polling endpoints.</li> </ul> <p>For broader vocabulary, see Glossary.</p>"},{"location":"workflows_rest_api/#gui-caller-map","title":"GUI caller map","text":"<ul> <li><code>seva/adapters/device_rest.py</code> -&gt; discovery and mode metadata endpoints.</li> <li><code>seva/adapters/job_rest.py</code> -&gt; validation/start/status/cancel/download endpoints.</li> <li><code>seva/adapters/firmware_rest.py</code> -&gt; firmware upload endpoint.</li> <li><code>seva/adapters/update_rest.py</code> -&gt; package-update upload/status endpoints.</li> <li><code>seva/adapters/discovery_http.py</code> -&gt; <code>/health</code> probe during box discovery.</li> </ul> <p>The corresponding usecases include experiment launch/poll/cancel flows and firmware flashing flows in <code>seva/usecases/</code>.</p>"},{"location":"workflows_rest_api/#workflow-1-start-poll-download-default-path","title":"Workflow 1: Start -&gt; Poll -&gt; Download (default path)","text":""},{"location":"workflows_rest_api/#deep-dive-steps","title":"Deep dive steps","text":"<ol> <li>GUI start flow posts <code>POST /jobs</code> with <code>JobRequest</code> payloads (one run per planned well).</li> <li><code>app.py</code> validates slot availability and required mode payload presence, sanitizes storage naming through <code>storage.py</code>, creates run directories, and starts slot worker threads.</li> <li>GUI polls status via <code>POST /jobs/status</code> (bulk) and/or <code>GET /jobs/{run_id}</code>.</li> <li><code>job_snapshot(...)</code> computes server-authoritative <code>progress_pct</code> and <code>remaining_s</code> via <code>progress_utils.compute_progress(...)</code>.</li> <li>After completion, GUI downloads artifacts via <code>GET /runs/{run_id}/zip</code> (or per-file endpoints).</li> </ol> <p>Validation note: <code>POST /modes/{mode}/validate</code> is available for explicit pre-flight checks, but is not mandatory in the default start orchestration.</p>"},{"location":"workflows_rest_api/#workflow-2-cancel-and-cleanup","title":"Workflow 2: Cancel and cleanup","text":"<ol> <li>GUI sends <code>POST /jobs/{run_id}/cancel</code>.</li> <li>API sets cancellation flag and immediately marks queued slots as cancelled.</li> <li>Running worker loops observe the cancel flag and attempt controller abort.</li> <li>API recomputes aggregate job state and frees slot reservations.</li> <li>Clients observe terminal state via polling endpoints.</li> </ol>"},{"location":"workflows_rest_api/#workflow-3-nas-setup-health-and-upload","title":"Workflow 3: NAS setup, health, and upload","text":"<ol> <li>GUI posts SMB credentials to <code>POST /nas/setup</code>.</li> <li><code>nas_smb.NASManager.setup(...)</code> writes config/credentials and runs a probe mount.</li> <li>GUI checks connectivity with <code>GET /nas/health</code>.</li> <li>Upload can be triggered manually via <code>POST /runs/{run_id}/upload</code> or by post-run automation in worker code.</li> <li>Upload worker mounts the share, copies files, verifies counts, and writes <code>UPLOAD_DONE</code> marker.</li> <li>Retention loop removes old locally uploaded runs based on configured retention days.</li> </ol>"},{"location":"workflows_rest_api/#workflow-4-firmware-flashing","title":"Workflow 4: Firmware flashing","text":"<ol> <li>GUI uploads <code>.bin</code> via <code>POST /firmware/flash</code>.</li> <li>API stores file in <code>/opt/box/firmware</code> with sanitized filename.</li> <li>API runs <code>python auto_flash_linux.py &lt;bin-path&gt;</code>.</li> <li>Script sends boot command, flashes with <code>dfu-util</code>, and waits for CDC reconnection.</li> <li>API returns command stdout/stderr and exit code; failures are mapped to typed API error payloads.</li> </ol>"},{"location":"workflows_rest_api/#workflow-5-remote-package-update-async","title":"Workflow 5: Remote package update (async)","text":"<ol> <li>GUI uploads one package ZIP to <code>POST /updates/package</code>.</li> <li>API stores upload in update staging storage and acquires a global update lock.</li> <li>Background worker validates <code>manifest.json</code> + <code>checksums.sha256</code> and rejects malformed packages with typed API codes.</li> <li>Worker applies only included components in fixed order (<code>pybeep</code>, <code>rest_api</code>, <code>firmware</code>).</li> <li>Firmware component flashing calls the same shared flash logic used by <code>POST /firmware/flash</code>.</li> <li>On successful apply, API executes restart command (<code>BOX_RESTART_COMMAND</code> override supported).</li> <li>GUI polls <code>GET /updates/{update_id}</code> for authoritative status/step/heartbeat until terminal.</li> </ol> <p>Partial package rule: any subset of components is valid; omitted components are marked <code>skipped</code>.</p>"},{"location":"workflows_rest_api/#workflow-6-telemetry-stream-demo-backend-capability","title":"Workflow 6: Telemetry stream demo (backend capability)","text":"<ol> <li>Client calls <code>/api/telemetry/temperature/latest</code> to fetch cache snapshot.</li> <li>Client opens SSE stream <code>/api/telemetry/temperature/stream</code>.</li> <li>API emits <code>temp</code> events and periodic <code>ping</code> keepalive events.</li> <li><code>latest_by_dev</code> cache updates continuously and remains available for snapshot endpoint.</li> </ol> <p>GUI integration note: the GUI settings expose a streaming toggle, but run-flow orchestration currently relies on polling (<code>POST /jobs/status</code>) as the production status channel.</p>"},{"location":"workflows_rest_api/#common-misunderstandings","title":"Common misunderstandings","text":"<ul> <li>\"The GUI computes progress on its own.\"</li> <li>Incorrect for the default flow: the API computes progress and ETA and returns them in snapshots.</li> <li>\"Validation must run before every start.\"</li> <li>Not required by default orchestration; explicit validate endpoint remains available.</li> <li>\"Streaming is the default status transport.\"</li> <li>Current production path uses polling for run lifecycle status.</li> </ul>"},{"location":"workflows_rest_api/#sequence-diagram","title":"Sequence diagram","text":"<pre><code>sequenceDiagram\n    participant GUI as GUI UseCase/ViewModel\n    participant Adapter as seva.adapters.*\n    participant API as rest_api.app\n    participant Storage as rest_api.storage\n    participant Worker as Slot Worker Thread\n    participant Device as pyBEEP Controller\n    participant NAS as rest_api.nas_smb\n\n    GUI-&gt;&gt;Adapter: Start experiment request\n    Adapter-&gt;&gt;API: POST /jobs\n    API-&gt;&gt;Storage: sanitize + create run directory\n    API-&gt;&gt;Worker: spawn per-slot worker threads\n    Worker-&gt;&gt;Device: execute measurement sequence\n    Worker--&gt;&gt;API: slot status updates\n\n    GUI-&gt;&gt;Adapter: Poll status\n    Adapter-&gt;&gt;API: POST /jobs/status\n    API--&gt;&gt;Adapter: Job snapshots (progress_pct, remaining_s)\n\n    GUI-&gt;&gt;Adapter: Download results\n    Adapter-&gt;&gt;API: GET /runs/{run_id}/zip\n    API--&gt;&gt;Adapter: ZIP bytes\n\n    API-&gt;&gt;NAS: enqueue_upload(run_id)\n    NAS--&gt;&gt;API: upload accepted / already queued\n</code></pre>"},{"location":"workflows_seva/","title":"SEVA Workflows","text":"<p>This document maps GUI actions to use cases in <code>seva/usecases</code>, then to adapter ports/endpoints. The goal is to make run orchestration and diagnostics traceable end-to-end.</p>"},{"location":"workflows_seva/#layer-contract-mvvm-hexagonal","title":"Layer Contract (MVVM + Hexagonal)","text":"<ul> <li>Views (<code>seva/app/views/*</code>) emit callbacks only.</li> <li>ViewModels (<code>seva/viewmodels/*</code>) hold UI state only.</li> <li>UseCases (<code>seva/usecases/*</code>) orchestrate workflow and validation.</li> <li>Adapters (<code>seva/adapters/*</code>) perform I/O and API payload transport.</li> <li>Server status remains authoritative for progress and phase information.</li> </ul>"},{"location":"workflows_seva/#ui-entrypoints-and-handoffs","title":"UI Entrypoints and Handoffs","text":"<p>Main composition happens in <code>seva/app/main.py</code> where callbacks are wired to presenter/controller actions.</p> <ul> <li><code>MainWindowView.on_submit</code> -&gt; <code>App._on_submit()</code> -&gt; <code>RunFlowPresenter.start_run()</code>.</li> <li><code>MainWindowView.on_cancel_group</code> -&gt; <code>App._on_cancel_group()</code> -&gt; <code>RunFlowPresenter.cancel_active_group()</code>.</li> <li><code>ExperimentPanelView.on_end_selection</code> -&gt; <code>App._on_end_selection()</code> -&gt; <code>RunFlowPresenter.cancel_selected_runs()</code>.</li> <li><code>MainWindowView.on_save_layout</code> / <code>on_load_layout</code> -&gt; <code>SavePlateLayout</code> / <code>LoadPlateLayout</code>.</li> <li>Settings dialog test/scan/package-update actions -&gt; <code>SettingsController</code> and <code>DiscoveryController</code> use-case calls.</li> <li><code>DownloadController.download_group_results()</code> handles run-artifact downloads.</li> </ul>"},{"location":"workflows_seva/#workflow-1-start-poll-complete","title":"Workflow 1: Start -&gt; Poll -&gt; Complete","text":"<ol> <li><code>RunFlowPresenter.start_run()</code> gathers configured wells from <code>PlateVM</code> and per-well mode snapshots from <code>ExperimentVM</code>.</li> <li><code>BuildExperimentPlan</code> validates typed snapshots and builds <code>ExperimentPlan</code>.</li> <li><code>BuildStorageMeta</code> builds <code>StorageMeta</code> from plan metadata and settings.</li> <li><code>RunFlowCoordinator.start()</code> calls <code>StartExperimentBatch</code>.</li> <li><code>StartExperimentBatch</code> delegates to <code>JobPort.start_batch</code> (<code>JobRestAdapter.start_batch</code> -&gt; <code>POST /jobs</code>).</li> <li>Presenter stores run metadata in <code>RunsRegistry</code>, schedules polling, and updates <code>ProgressVM</code>/<code>RunsVM</code>.</li> <li>Poll ticks call <code>RunFlowCoordinator.poll_once()</code> -&gt; <code>PollGroupStatus</code>.</li> <li><code>PollGroupStatus</code> calls <code>JobPort.poll_group</code> (<code>JobRestAdapter.poll_group</code> -&gt; <code>POST /jobs/status</code>) and normalizes to <code>GroupSnapshot</code>.</li> <li>On completion (<code>snapshot.all_done</code>), coordinator optionally auto-downloads via <code>DownloadGroupResults</code>.</li> </ol> <pre><code>sequenceDiagram\n    participant U as User\n    participant V as MainWindowView\n    participant P as RunFlowPresenter\n    participant BP as BuildExperimentPlan\n    participant BS as BuildStorageMeta\n    participant C as RunFlowCoordinator\n    participant SB as StartExperimentBatch\n    participant JP as JobPort/JobRestAdapter\n    participant API as REST API\n\n    U-&gt;&gt;V: Click Start\n    V-&gt;&gt;P: start_run()\n    P-&gt;&gt;BP: build ExperimentPlan\n    BP--&gt;&gt;P: ExperimentPlan\n    P-&gt;&gt;BS: build StorageMeta\n    BS--&gt;&gt;P: StorageMeta\n    P-&gt;&gt;C: start(plan, storage_meta)\n    C-&gt;&gt;SB: __call__(plan)\n    SB-&gt;&gt;JP: start_batch(plan)\n    JP-&gt;&gt;API: POST /jobs\n    API--&gt;&gt;JP: run_group_id + run_ids\n    JP--&gt;&gt;SB: typed result\n    SB--&gt;&gt;C: StartBatchResult\n    C--&gt;&gt;P: GroupContext\n\n    loop polling\n      P-&gt;&gt;C: poll_once(ctx)\n      C-&gt;&gt;JP: poll_group(group_id)\n      JP-&gt;&gt;API: POST /jobs/status\n      API--&gt;&gt;JP: status payload\n      JP--&gt;&gt;C: GroupSnapshot\n      C--&gt;&gt;P: FlowTick\n    end\n</code></pre> <p>Outcome: a typed plan is submitted once, server snapshots drive all progress updates, and completion can trigger download automatically.</p>"},{"location":"workflows_seva/#workflow-2-download-group-results","title":"Workflow 2: Download Group Results","text":"<ol> <li>User triggers download from run overview/runs panel.</li> <li><code>DownloadController</code> resolves active group and metadata from <code>RunFlowPresenter</code>.</li> <li><code>DownloadGroupResults</code> validates <code>StorageMeta</code> and calls <code>JobPort.download_group_zip</code>.</li> <li><code>JobRestAdapter.download_group_zip</code> fetches per-run archives (<code>GET /runs/{run_id}/zip</code>).</li> <li>Use case extracts ZIPs, renames <code>slotNN</code> folders to well IDs via adapter slot registry, and applies cleanup mode (<code>keep|delete|archive</code>).</li> </ol> <pre><code>sequenceDiagram\n    participant U as User\n    participant D as DownloadController\n    participant P as RunFlowPresenter\n    participant UC as DownloadGroupResults\n    participant JP as JobPort/JobRestAdapter\n    participant API as REST API\n    participant FS as Filesystem\n\n    U-&gt;&gt;D: Download group\n    D-&gt;&gt;P: resolve group + storage meta\n    D-&gt;&gt;UC: __call__(group_id, target, storage_meta)\n    UC-&gt;&gt;JP: download_group_zip(group_id, root)\n    JP-&gt;&gt;API: GET /runs/{run_id}/zip\n    API--&gt;&gt;JP: ZIP stream(s)\n    JP--&gt;&gt;UC: zip_root\n    UC-&gt;&gt;FS: extract + slot-&gt;well rename\n    UC--&gt;&gt;D: extraction_root\n</code></pre> <p>Outcome: results are unpacked under <code>&lt;results&gt;/&lt;experiment&gt;/&lt;subdir?&gt;/&lt;client_datetime&gt;/...</code> with deterministic well folder names.</p>"},{"location":"workflows_seva/#workflow-3-cancellation","title":"Workflow 3: Cancellation","text":"<ul> <li>Group cancel: <code>RunFlowPresenter.cancel_active_group()</code> -&gt; <code>CancelGroup</code> -&gt; <code>JobPort.cancel_group</code>.</li> <li>Selected-run cancel: <code>RunFlowPresenter.cancel_selected_runs()</code> -&gt; <code>CancelRuns</code> -&gt; <code>JobPort.cancel_run</code> per unique run id.</li> <li>Errors from adapters are mapped by <code>map_api_error</code> to stable <code>UseCaseError</code> codes/messages.</li> </ul> <pre><code>sequenceDiagram\n    participant U as User\n    participant P as RunFlowPresenter\n    participant CG as CancelGroup\n    participant CR as CancelRuns\n    participant JP as JobPort\n\n    alt cancel active group\n      U-&gt;&gt;P: Cancel Group\n      P-&gt;&gt;CG: __call__(group_id)\n      CG-&gt;&gt;JP: cancel_group(group_id)\n    else cancel selected runs\n      U-&gt;&gt;P: End Selection\n      P-&gt;&gt;CR: __call__(box_to_run_ids)\n      CR-&gt;&gt;JP: cancel_run(box_id, run_id)\n    end\n</code></pre> <p>Outcome: cancellation orchestration stays in use cases, with shared error semantics.</p>"},{"location":"workflows_seva/#workflow-4-discovery-and-assignment","title":"Workflow 4: Discovery and Assignment","text":"<ol> <li><code>DiscoveryController.discover()</code> builds candidates from configured base URLs and subnet hints.</li> <li><code>DiscoverAndAssignDevices</code> calls <code>DiscoverDevices</code> (<code>DeviceDiscoveryPort.discover</code>, usually <code>HttpDiscoveryAdapter</code>).</li> <li>Discovered URLs are merged via <code>MergeDiscoveredIntoRegistry</code>.</li> <li>Empty configured slots are assigned in order; overflow URLs are reported as skipped.</li> <li>Updated registry is pushed to <code>SettingsVM</code> and persisted via <code>StoragePort.save_user_settings</code>.</li> </ol> <pre><code>sequenceDiagram\n    participant U as User\n    participant DC as DiscoveryController\n    participant DA as DiscoverAndAssignDevices\n    participant DD as DiscoverDevices\n    participant DP as DeviceDiscoveryPort\n    participant S as SettingsVM\n    participant ST as StoragePort\n\n    U-&gt;&gt;DC: Scan network\n    DC-&gt;&gt;DA: DiscoveryRequest\n    DA-&gt;&gt;DD: discover(candidates)\n    DD-&gt;&gt;DP: discover(...)\n    DP--&gt;&gt;DD: DiscoveredBox[]\n    DD--&gt;&gt;DA: DiscoveredBox[]\n    DA--&gt;&gt;DC: DiscoveryResult\n    DC-&gt;&gt;S: apply normalized_registry\n    DC-&gt;&gt;ST: save_user_settings(...)\n</code></pre> <p>Outcome: reachable devices are discovered and assigned to open slots without manual URL editing.</p>"},{"location":"workflows_seva/#workflow-5-diagnostics-and-control","title":"Workflow 5: Diagnostics and Control","text":"<ul> <li><code>TestConnection</code>: settings test action -&gt; <code>DevicePort.health</code> + <code>DevicePort.list_devices</code> (REST: <code>/health</code>, <code>/devices</code>).</li> <li><code>PollDeviceStatus</code>: periodic activity polling -&gt; <code>DevicePort.list_device_status</code> + <code>list_devices</code> -&gt; <code>DeviceActivitySnapshot</code> for <code>ProgressVM</code>.</li> <li><code>TestRelay</code>: relay diagnostics action -&gt; <code>RelayPort.test</code>.</li> <li><code>SetElectrodeMode</code>: electrode mode toggle -&gt; <code>RelayPort.set_electrode_mode</code>.</li> <li><code>StartRemoteUpdate</code>: settings package-update action -&gt; <code>UpdatePort.start_package_update</code> (REST: <code>POST /updates/package</code>).</li> <li><code>PollRemoteUpdate</code>: modal polling loop -&gt; <code>UpdatePort.get_package_update</code> (REST: <code>GET /updates/{update_id}</code>).</li> </ul> <p>Outcome: diagnostics remain adapter-agnostic at use-case level while surfacing typed status to the UI.</p>"},{"location":"workflows_seva/#workflow-6-layout-persistence","title":"Workflow 6: Layout Persistence","text":"<ol> <li>Save action calls <code>SavePlateLayout</code> with <code>ExperimentVM</code> state (selection + per-well params).</li> <li><code>StoragePort.save_layout</code> persists payload.</li> <li>Load action calls <code>LoadPlateLayout</code>.</li> <li><code>LoadPlateLayout</code> normalizes payload and reapplies it to <code>ExperimentVM</code> and <code>PlateVM</code>.</li> </ol> <p>Outcome: plate configurations round-trip through storage without view-level file I/O logic.</p>"},{"location":"workflows_seva/#usecase-inventory-trigger-adapterport","title":"UseCase Inventory (Trigger -&gt; Adapter/Port)","text":"<ul> <li><code>apply_ir_correction.ApplyIRCorrection</code>: processing hook placeholder; currently passthrough, no adapter call.</li> <li><code>build_experiment_plan.BuildExperimentPlan</code>: run start path from presenter; no adapter call.</li> <li><code>build_storage_meta.BuildStorageMeta</code>: run start/download metadata preparation; no adapter call.</li> <li><code>start_experiment_batch.StartExperimentBatch</code>: run start; <code>JobPort.start_batch</code>.</li> <li><code>poll_group_status.PollGroupStatus</code>: run polling; <code>JobPort.poll_group</code>.</li> <li><code>download_group_results.DownloadGroupResults</code>: download flow; <code>JobPort.download_group_zip</code> + filesystem.</li> <li><code>cancel_group.CancelGroup</code>: cancel active group; <code>JobPort.cancel_group</code>.</li> <li><code>cancel_runs.CancelRuns</code>: cancel selected runs; <code>JobPort.cancel_run</code>.</li> <li><code>run_flow_coordinator.RunFlowCoordinator</code>: orchestration wrapper around start/poll/download use cases.</li> <li><code>discover_devices.DiscoverDevices</code>: settings scan; <code>DeviceDiscoveryPort.discover</code>.</li> <li><code>discover_devices.MergeDiscoveredIntoRegistry</code>: settings scan helper; no adapter call.</li> <li><code>discover_and_assign_devices.DiscoverAndAssignDevices</code>: scan + assignment orchestration; discovery port via nested use case.</li> <li><code>test_connection.TestConnection</code>: settings connection test; <code>DevicePort.health</code> + <code>DevicePort.list_devices</code>.</li> <li><code>poll_device_status.PollDeviceStatus</code>: activity polling; <code>DevicePort.list_device_status</code> + <code>DevicePort.list_devices</code>.</li> <li><code>start_remote_update.StartRemoteUpdate</code>: settings package-update upload; <code>UpdatePort.start_package_update</code>.</li> <li><code>poll_remote_update.PollRemoteUpdate</code>: settings package-update polling; <code>UpdatePort.get_package_update</code>.</li> <li><code>test_relay.TestRelay</code>: relay diagnostics; <code>RelayPort.test</code>.</li> <li><code>set_electrode_mode.SetElectrodeMode</code>: relay control; <code>RelayPort.set_electrode_mode</code>.</li> <li><code>save_plate_layout.SavePlateLayout</code>: toolbar save layout; <code>StoragePort.save_layout</code>.</li> <li><code>load_plate_layout.LoadPlateLayout</code>: toolbar load layout; <code>StoragePort.load_layout</code>.</li> <li><code>error_mapping.map_api_error</code>: shared adapter-error to use-case-error mapping utility.</li> <li><code>load_device_status</code> module: reserved for future orchestration.</li> </ul>"}]}