"""Filesystem adapter implementing ``StoragePort``.

This module persists layout and user-settings payloads as JSON files under a
configurable root directory.

Dependencies:
    - ``json`` for serialization/deserialization.
    - ``tempfile`` + ``os.replace`` for atomic settings writes.

Call context:
    - ``SavePlateLayout`` and ``LoadPlateLayout`` use cases.
    - App/settings/discovery controllers for runtime preference persistence.
"""

from __future__ import annotations

import json
import os
import tempfile
from pathlib import Path
from typing import Dict

from seva.domain.ports import StoragePort
from seva.viewmodels.settings_vm import default_settings_payload


class StorageLocal(StoragePort):
    """Local JSON-backed storage implementation for GUI data."""

    def __init__(self, root_dir: str = ".") -> None:
        """Initialize storage adapter.

        Args:
            root_dir: Root directory for layout and settings files.
        """
        self.root = Path(root_dir)

    # ---- Layouts (JSON) ----
    def save_layout(self, name: str, payload: Dict) -> Path:
        """Save layout payload to normalized JSON path.

        Args:
            name: Layout name or relative path.
            payload: Layout JSON payload generated by use case.

        Returns:
            Absolute/relative path where JSON was written.

        Side Effects:
            Creates parent directories when missing.
            Writes file content to disk.
        """
        path = self._layout_path(name)
        path.parent.mkdir(parents=True, exist_ok=True)
        with path.open("w", encoding="utf-8") as fh:
            json.dump(
                payload,
                fh,
                ensure_ascii=False,
                sort_keys=True,
                separators=(",", ":"),
            )
        return path

    def load_layout(self, name: str | Path) -> Dict:
        """Load layout payload from normalized path.

        Args:
            name: Layout name or relative path.

        Returns:
            Dictionary with normalized keys ``selection`` and ``well_params_map``.
        """
        path = self._layout_path(name)
        with path.open("r", encoding="utf-8") as fh:
            raw = json.load(fh)
        well_params_map = dict(raw.get("well_params_map") or {})
        selection = list(raw.get("selection") or [])
        return {"selection": selection, "well_params_map": well_params_map}

    # ---- User settings (JSON) ----
    def load_user_settings(self) -> Dict:
        """Load persisted user settings or defaults when missing.

        Returns:
            Settings dictionary consumed by ``SettingsVM.apply_dict``.

        Raises:
            ValueError: If stored payload is not a JSON object.
        """
        path = self.root / "user_settings.json"
        if not path.exists():
            return default_settings_payload()
        with path.open("r", encoding="utf-8") as fh:
            raw = json.load(fh)
        if not isinstance(raw, dict):
            raise ValueError("User settings payload must be a JSON object.")
        return raw

    def save_user_settings(self, payload: Dict) -> None:
        """Persist settings payload with atomic replace semantics.

        Args:
            payload: Settings dictionary to serialize.

        Side Effects:
            Writes temporary file in settings directory, fsyncs, then replaces the
            final ``user_settings.json`` file atomically.
        """
        path = self.root / "user_settings.json"
        path.parent.mkdir(parents=True, exist_ok=True)
        fd, tmp_path = tempfile.mkstemp(
            dir=str(path.parent), prefix="user_settings_", suffix=".tmp"
        )
        try:
            with os.fdopen(fd, "w", encoding="utf-8") as tmp_fh:
                json.dump(payload, tmp_fh, ensure_ascii=False, indent=2)
                tmp_fh.flush()
                os.fsync(tmp_fh.fileno())
            # ``os.replace`` is atomic on supported filesystems and prevents
            # partially-written settings files during crashes.
            os.replace(tmp_path, path)
        finally:
            if os.path.exists(tmp_path):
                try:
                    os.remove(tmp_path)
                except FileNotFoundError:
                    pass

    def _layout_path(self, name: str | Path) -> Path:
        """Resolve layout filename and enforce ``layout_*.json`` naming.

        Args:
            name: Layout name or path candidate.

        Returns:
            Path rooted at ``self.root`` unless ``name`` is absolute.

        Raises:
            ValueError: If candidate name is empty.
        """
        candidate = Path(name)
        if candidate.is_absolute():
            return candidate
        parent = candidate.parent if candidate.parent != Path(".") else Path()
        raw_name = candidate.name
        if not raw_name:
            raise ValueError("Layout name must not be empty.")
        if raw_name.startswith("layout_") and candidate.suffix.lower() == ".json":
            filename = raw_name
        else:
            stem = candidate.stem if candidate.suffix else raw_name
            if not stem.startswith("layout_"):
                stem = f"layout_{stem}"
            filename = f"{stem}.json"
        return self.root / parent / filename
